<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>进程调度 on Kunkka</title><link>https://MyLoveES.github.io/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</link><description>Recent content in 进程调度 on Kunkka</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 11 Apr 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://MyLoveES.github.io/tags/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/index.xml" rel="self" type="application/rss+xml"/><item><title>Process Scheduling In Linux</title><link>https://MyLoveES.github.io/p/process-scheduling-in-linux/</link><pubDate>Mon, 11 Apr 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/process-scheduling-in-linux/</guid><description>&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/process-scheduling-in-linux/ProcessSchedulingInLinux.jpeg"
width="700"
height="466"
srcset="https://MyLoveES.github.io/p/process-scheduling-in-linux/ProcessSchedulingInLinux_hu_7981959e63eea4f8.jpeg 480w, https://MyLoveES.github.io/p/process-scheduling-in-linux/ProcessSchedulingInLinux_hu_20f4a832956208a7.jpeg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="150"
data-flex-basis="360px"
&gt;&lt;/p&gt;
&lt;h1 id="调度-scheduling"&gt;调度 Scheduling
&lt;/h1&gt;&lt;p&gt;调度是进行资源分配的一种行为。在单线程、多线程之间进行调度任务。&lt;/p&gt;
&lt;h1 id="目标-target"&gt;目标 Target
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;最大吞吐量(单位时间内完成的任务量)&lt;/li&gt;
&lt;li&gt;最小的等待时间(进程准备就绪到开始执行经过的时间)&lt;/li&gt;
&lt;li&gt;最小的响应时间(进程准备就绪到执行完成经过的时间)&lt;/li&gt;
&lt;li&gt;最大的公平性(为每个进程公平地分配资源)&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="linux-中的两种进程类型"&gt;Linux 中的两种进程类型
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;实时进程&lt;/li&gt;
&lt;li&gt;常规进程&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="实时进程"&gt;实时进程
&lt;/h2&gt;&lt;p&gt;实时进程需要服从个响应时间的限制，而不去考虑系统负载。换句话说，实时进程是紧急的，任何情况下都不能延迟。&lt;br&gt;
举个例子来说，Linux中的负载均衡进程，负责跨CPU内核分配进程。&lt;/p&gt;
&lt;h2 id="常规进程"&gt;常规进程
&lt;/h2&gt;&lt;p&gt;传统进程没有严格的响应时间的限制，如果系统忙碌，响应会出现延迟。&lt;br&gt;
比如浏览器的进程，忙碌时加载页面会出现延迟。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每种进程都有不同的调度算法，只要有准备运行的实时进程，它们就会运行并使常规进程等待。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="实时调度"&gt;实时调度
&lt;/h1&gt;&lt;p&gt;实时调度有两种调度策略，SCHED_RR 和 SCHED_FIFO。&lt;br&gt;
该策略会影响进程将获得多少运行时间以及运行队列的运行方式。&lt;br&gt;
准备运行的进程存储在一个名为 runqueue 的队列中。调度程序正在根据策略从该运行队列中选择要运行的进程。&lt;/p&gt;
&lt;h2 id="sched_fifo"&gt;SCHED_FIFO
&lt;/h2&gt;&lt;p&gt;在此策略中，调度程序将根据到达时间（FIFO = 先进先出）选择一个进程。&lt;br&gt;
具有 SCHED_FIFO 调度策略的进程可以在以下几种情况下“放弃”CPU：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;进程正在等待，例如等待 IO 操作。 当进程回到“就绪”状态时，它将回到运行队列的末尾。&lt;/li&gt;
&lt;li&gt;进程通过系统调用 sched_yield 让出 CPU。 该过程将立即返回到运行队列的末尾。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="sched_rr"&gt;SCHED_RR
&lt;/h2&gt;&lt;p&gt;RR = Round Robin&lt;br&gt;
在此调度策略中，运行队列中的每个进程都获得一个时间片（单位量）并以循环方式轮流执行（基于优先级）。 &lt;br&gt;
为了让我们对循环有更好的理解，让我们考虑一个例子，我们的运行队列中有 3 个进程 A B C，它们都具有 SCHED_RR 的策略。&lt;br&gt;
如下图所示，每个进程都得到一个时间片并轮流执行。当所有进程运行 1 次时，它们会重复相同的执行顺序。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/process-scheduling-in-linux/rr.png"
width="408"
height="181"
srcset="https://MyLoveES.github.io/p/process-scheduling-in-linux/rr_hu_e4ec489117992c76.png 480w, https://MyLoveES.github.io/p/process-scheduling-in-linux/rr_hu_b00204104a4a2463.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="225"
data-flex-basis="540px"
&gt;&lt;/p&gt;
&lt;h2 id="实时调度总结"&gt;实时调度总结
&lt;/h2&gt;&lt;p&gt;实时进程可以在两种不同的策略 SCHED_FIFO 和 SCHED_RR 中实现调度。该策略会影响运行队列的工作方式以及每个进程执行的时间。&lt;/p&gt;
&lt;h1 id="常规调度"&gt;常规调度
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;CFS — Completely Fair Scheduler 是 Linux 2.6.23 版本以来常规进程的调度算法。&lt;br&gt;
CFS 主要关注一个指标——它希望尽可能公平，这意味着他让每个进程都获得 CPU 的平均时间片。&lt;br&gt;
请注意，具有更高优先级的进程可能仍会获得更大的时间片。 为了让我们了解 CFS 的工作原理，我们必须熟悉一个新术语——虚拟运行时（vruntime）。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h2 id="virtual-runtime"&gt;Virtual Runtime
&lt;/h2&gt;&lt;p&gt;进程的虚拟运行时间是实际执行所花费的时间，不包括任何形式的等待。&lt;br&gt;
CFS 力求尽可能公平。 为此，CFS 将以准备运行的最短虚拟时间安排进程。&lt;br&gt;
CFS 维护保持最大和最小虚拟运行时间的变量，原因我们很快就会明白。&lt;/p&gt;
&lt;h2 id="cfs--完全公平的调度器"&gt;CFS — 完全公平的调度器
&lt;/h2&gt;&lt;p&gt;在讨论算法是如何工作的之前，让我们先了解一下这个算法使用的是什么数据结构。&lt;br&gt;
CFS 使用红黑树，它是一种平衡的二叉搜索树——这意味着插入、删除和查找在 O(logN) 中执行，其中 N 是进程数。&lt;br&gt;
这棵树中的关键是进程的&lt;strong&gt;虚拟&lt;/strong&gt;运行时。&lt;br&gt;
新进程或从等待中恢复到就绪状态的进程插入到树中，键为 vruntime=min_vruntime。这对于防止树中旧进程的饥饿非常重要。&lt;/p&gt;
&lt;p&gt;继续介绍算法，首先，算法为自己设置了一个时间限制 —— sched_latency。 &lt;br&gt;
在这个时间限制内，它将尝试执行所有准备好的进程 —— N。&lt;br&gt;
这意味着每个进程将获得时间限制除以进程数的时间片 —— Qᵢ = sched_latency/N。&lt;br&gt;
当一个进程完成其时间片 (Qᵢ) 时，算法会选择树中虚拟运行时间最少的进程来执行下一个。&lt;/p&gt;
&lt;p&gt;让我们解决一个我迄今为止描述算法的方式可能存在问题的情况。&lt;br&gt;
假设算法选择了 48ms（毫秒）的时间限制，我们有 6 个进程——在这种情况下，每个进程都有 8ms 的时间轮流执行。&lt;/p&gt;
&lt;p&gt;但是当系统中的进程过载时会发生什么？ 假设时间限制仍然是 48 毫秒，但现在我们有 32 个进程，现在每个进程有 1.5 毫秒的执行时间——这将导致我们的系统严重减速。&lt;/p&gt;
&lt;h3 id="why-whats-the-difference"&gt;Why? What’s the difference?
&lt;/h3&gt;&lt;p&gt;上下文切换。 &lt;br&gt;
上下文切换是一个存储进程或线程状态的过程，以便它可以在以后恢复并恢复执行。&lt;/p&gt;
&lt;p&gt;每次进程完成其执行时间并安排新进程时，都会发生上下文切换，这也需要时间。&lt;/p&gt;
&lt;p&gt;假设上下文切换花费了我们 1 毫秒，在第一个示例中，每个进程有 6 毫秒，我们可以允许这样做，我们在上下文切换上浪费了 1 毫秒，在实际执行进程上浪费了 5 毫秒。但是在第二个例子中，我们只有 0.5ms 来执行这个过程——我们浪费了大部分时间片来进行上下文切换，这就是它根本无法工作的原因。&lt;/p&gt;
&lt;p&gt;为了克服这种情况，我们引入了一个新变量，它将确定允许的时间片有多小——min_granularity。&lt;/p&gt;
&lt;p&gt;假设 min_granularity=6ms 并回到我们的示例。 我们的时间限制是 48，我们有 32 个进程。
根据我们之前的计算，每个进程都会得到 1.5ms，但现在根本不允许，因为 min_granularity 指定了每个进程应该得到的最小时间片。
在这种情况下，当 Qᵢ &amp;lt; min_granularity 我们将 min_granularity 作为我们的 Qᵢ 并根据它更改时间限制。&lt;br&gt;
在我们的示例中，Qᵢ 将等于 6ms，因为 1.5ms &amp;lt; 6ms，这意味着新的时间限制将是 Qᵢ ⋅ N = 6ms ⋅ 32 = 192ms。&lt;/p&gt;
&lt;h1 id="diff-between-cfs-and-rr"&gt;diff between cfs and rr
&lt;/h1&gt;&lt;p&gt;在这一点上，可能不清楚 CFS 和 RR 之间的区别是什么，因为它们都定义了一些时间片并使进程以某种顺序执行。&lt;br&gt;
为了总结和更好地理解这些算法之间的差异，这里有一个简短的表格
&lt;img src="https://MyLoveES.github.io/p/process-scheduling-in-linux/table.jpeg"
width="700"
height="240"
srcset="https://MyLoveES.github.io/p/process-scheduling-in-linux/table_hu_11ffa638d3a42c11.jpeg 480w, https://MyLoveES.github.io/p/process-scheduling-in-linux/table_hu_3f69efdd8f2f07af.jpeg 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="291"
data-flex-basis="700px"
&gt;&lt;/p&gt;
&lt;h1 id="ref"&gt;Ref
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;a class="link" href="https://medium.com/geekculture/process-scheduling-in-linux-592028a5d545" target="_blank" rel="noopener"
&gt;Process Scheduling In Linux&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description></item></channel></rss>