<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>并发 on Kunkka</title><link>https://MyLoveES.github.io/tags/%E5%B9%B6%E5%8F%91/</link><description>Recent content in 并发 on Kunkka</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Mon, 10 Mar 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://MyLoveES.github.io/tags/%E5%B9%B6%E5%8F%91/index.xml" rel="self" type="application/rss+xml"/><item><title>Event Loop</title><link>https://MyLoveES.github.io/p/event-loop/</link><pubDate>Mon, 10 Mar 2025 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/event-loop/</guid><description>&lt;h1 id="事件循环"&gt;事件循环
&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id="一事件循环的本质从快递分拣中心说起"&gt;一、事件循环的本质：从快递分拣中心说起
&lt;/h2&gt;&lt;h3 id="11-现实世界类比"&gt;1.1 现实世界类比
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-plaintext" data-lang="plaintext"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;假设你经营一家快递分拣中心：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- **传统阻塞模型**（多线程）：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 每个包裹（请求）分配一个工人（线程）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 工人必须全程跟踪包裹：接收 → 分拣 → 装车
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 即使工人90%时间在等待货车，也不能处理其他包裹
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;- **事件循环模型**：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 少数高效工人（事件循环线程）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 每个工人管理多个传送带（Socket通道）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 工人只处理就绪的包裹（就绪的I/O事件）
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="12-传统模型的瓶颈"&gt;1.2 传统模型的瓶颈
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;事件循环（Event Loop）：&lt;/strong&gt;
一种程序结构，通过无限循环持续监听并分发I/O事件，其核心组件包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;事件队列：存储待处理事件（新连接、数据到达等）&lt;/li&gt;
&lt;li&gt;事件分发器：检测哪些通道（Channel）已就绪&lt;/li&gt;
&lt;li&gt;事件处理器：处理具体I/O操作的回调函数&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="二多路复用技术事件循环的火眼金睛"&gt;二、多路复用技术：事件循环的&amp;quot;火眼金睛&amp;quot;
&lt;/h2&gt;&lt;h3 id="21-从bio到nio的演进"&gt;2.1 从BIO到NIO的演进
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;工作方式&lt;/th&gt;
&lt;th&gt;资源消耗&lt;/th&gt;
&lt;th&gt;适用场景&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;BIO&lt;/td&gt;
&lt;td&gt;1线程1连接（阻塞等待）&lt;/td&gt;
&lt;td&gt;随连接数线性增长&lt;/td&gt;
&lt;td&gt;低并发场景&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;select&lt;/td&gt;
&lt;td&gt;遍历所有fd检查状态&lt;/td&gt;
&lt;td&gt;O(n)时间复杂度&lt;/td&gt;
&lt;td&gt;少量连接&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;epoll&lt;/td&gt;
&lt;td&gt;回调通知就绪事件&lt;/td&gt;
&lt;td&gt;O(1)时间复杂度&lt;/td&gt;
&lt;td&gt;万级连接&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id="22-epoll的三大核心能力"&gt;2.2 epoll的三大核心能力
&lt;/h2&gt;&lt;h3 id="221-红黑树管理文件描述符集"&gt;2.2.1 红黑树管理文件描述符集
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 创建epoll实例
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;epoll_fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;epoll_create1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 添加监控描述符
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;epoll_event&lt;/span&gt; &lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EPOLLIN&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="n"&gt;EPOLLET&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 边缘触发模式
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="nf"&gt;epoll_ctl&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epoll_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EPOLL_CTL_ADD&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;socket_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="221-就绪列表与事件回调"&gt;2.2.1 就绪列表与事件回调
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;span class="lnt"&gt;9
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-c" data-lang="c"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 等待事件发生（毫秒级超时）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;num_events&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nf"&gt;epoll_wait&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;epoll_fd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MAX_EVENTS&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;// 处理就绪事件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c1"&gt;&lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;num_events&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;EPOLLIN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="nf"&gt;handle_read&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;events&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fd&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="223-触发模式选择"&gt;2.2.3 触发模式选择
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;水平触发（LT）：只要缓冲区有数据就会持续通知&lt;/li&gt;
&lt;li&gt;边缘触发（ET）：仅在状态变化时通知一次（性能更优）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="三netty的事件循环实现"&gt;三、Netty的事件循环实现
&lt;/h2&gt;&lt;h3 id="31-核心组件关系图"&gt;3.1 核心组件关系图
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;┌───────────────────────────┐
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ EventLoopGroup │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ ┌─────────────────────┐ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ NioEventLoop[] │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ ┌─────────────────┐ │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ │ Selector │ │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ │ (epoll实例) │ │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ └─────────────────┘ │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ │ Task Queue │ │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ │ └─────────────────┘ │ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;│ └─────────────────────┘ │
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;└───────────────────────────┘
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="32-事件循环线程的生命周期"&gt;3.2 事件循环线程的生命周期
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;span class="lnt"&gt;24
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;// 简化版事件循环伪代码
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;public void run() {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; while (!terminated) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; // 阶段1：检测I/O事件
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; int readyChannels = selector.select(timeout);
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; // 阶段2：处理I/O事件
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (readyChannels &amp;gt; 0) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; Set&amp;lt;SelectionKey&amp;gt; keys = selector.selectedKeys();
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; for (SelectionKey key : keys) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (key.isReadable()) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; handleRead(key);
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if (key.isWritable()) {
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; handleWrite(key);
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; keys.clear();
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; // 阶段3：处理异步任务
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; runAllTasks();
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; }
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="33-关键性能优化手段"&gt;3.3 关键性能优化手段
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;I/O比例控制：通过ioRatio参数平衡I/O与任务处理时间&lt;/li&gt;
&lt;/ol&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;// 默认配置：I/O操作占用50%时间
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;NioEventLoopGroup group = new NioEventLoopGroup(4, new DefaultThreadFactory(), 50);
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ol start="2"&gt;
&lt;li&gt;直接内存分配：使用ByteBuf避免JVM堆内存拷贝&lt;/li&gt;
&lt;li&gt;零拷贝技术：文件传输通过FileRegion直接操作内核缓冲区&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="四性能对比理论-vs-现实"&gt;四、性能对比：理论 vs 现实
&lt;/h2&gt;&lt;h3 id="41-理论计算模型"&gt;4.1 理论计算模型
&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;C10K问题公式推导：&lt;/strong&gt;
传统模型所需线程数 = 并发连接数 × (平均等待时间 / 平均处理时间)
假设：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;10,000并发连接&lt;/li&gt;
&lt;li&gt;每个请求95%时间在等待（19ms等待 + 1ms处理）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;传统模型线程数 = 10,000 × (19/1) = 190,000 → 完全不可行&lt;br&gt;
事件循环模型线程数 = CPU核心数（如4线程）→ 轻松应对&lt;/p&gt;
&lt;h2 id="五从内核到应用全链路视角看事件循环"&gt;五、从内核到应用：全链路视角看事件循环
&lt;/h2&gt;&lt;h3 id="51-linux内核的工作流程"&gt;5.1 Linux内核的工作流程
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;应用层（Java NIO）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ↓ 系统调用（epoll_ctl/epoll_wait）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;VFS（虚拟文件系统层）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ↓ 回调注册
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;网卡驱动
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ↓ 硬件中断
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;DMA缓冲区 → 数据就绪 → 触发epoll回调
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="52-现代网络栈优化"&gt;5.2 现代网络栈优化
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;RSS（接收端扩展）：多队列网卡分散中断压力&lt;/li&gt;
&lt;li&gt;SO_REUSEPORT：允许多个Socket监听同一端口&lt;/li&gt;
&lt;li&gt;Kernel Bypass：DPDK/XDK等用户态网络方案&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="六最佳实践如何最大化事件循环效率"&gt;六、最佳实践：如何最大化事件循环效率
&lt;/h2&gt;&lt;h3 id="61-配置原则"&gt;6.1 配置原则
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-yaml" data-lang="yaml"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="c"&gt;# 推荐Netty配置&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="nt"&gt;server&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;netty&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;event-loop&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;boss-count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# 接收连接线程数&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;worker-count&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="l"&gt;cpu_cores * 2&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# 处理I/O线程数&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;max-initial-line-length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;8192&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nt"&gt;so-backlog&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="m"&gt;1024&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="c"&gt;# 等待连接队列大小&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="62-禁忌事项"&gt;6.2 禁忌事项
&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;❌ 在事件循环线程执行阻塞操作&lt;/li&gt;
&lt;li&gt;❌ 忘记释放ByteBuf导致内存泄漏&lt;/li&gt;
&lt;li&gt;❌ 在Handler中处理耗时业务逻辑&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="63-监控指标"&gt;6.3 监控指标
&lt;/h3&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;关键Metric：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; reactor.netty.io.allocated.direct：直接内存使用量
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; reactor.netty.io.pending.tasks：待处理任务数
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; reactor.netty.io.select.latency：select操作延迟
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>Why threads are a bad idea (for most purposes)</title><link>https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/</guid><description>&lt;p&gt;// 发现本文很多概念在现在已经不适用了，不做参考&lt;/p&gt;
&lt;h1 id="threads"&gt;Threads
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;诞生于操作系统的发展&lt;/li&gt;
&lt;li&gt;演变为用户级别的工具&lt;/li&gt;
&lt;li&gt;作为各种问题的解决方案&lt;/li&gt;
&lt;li&gt;每个程序员都应该是线程程序员？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="什么是线程"&gt;什么是线程
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/Threads.png"
width="1468"
height="536"
srcset="https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/Threads_hu_7f82b31f2c00a7fc.png 480w, https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/Threads_hu_1da6e77f16e20fe3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="657px"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于管理并发的通用解决方案&lt;/li&gt;
&lt;li&gt;执行流彼此独立&lt;/li&gt;
&lt;li&gt;共享状态&lt;/li&gt;
&lt;li&gt;抢占式调度&lt;/li&gt;
&lt;li&gt;同步（例如锁、条件）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="问题"&gt;问题
&lt;/h2&gt;&lt;p&gt;线程编程很难用&lt;/p&gt;
&lt;h2 id="为啥这么难用"&gt;为啥这么难用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;必须对共享资源加锁来控制访问&lt;/li&gt;
&lt;li&gt;由锁产生的死锁问题&lt;/li&gt;
&lt;li&gt;难以 debug. 依赖数据和时间&lt;/li&gt;
&lt;li&gt;难以抽象 modules&lt;/li&gt;
&lt;li&gt;回调在加锁的场景下很难用&lt;/li&gt;
&lt;li&gt;很难取得好的性能：
&lt;ol&gt;
&lt;li&gt;简单的锁(例如监视器)产生低并发性&lt;/li&gt;
&lt;li&gt;细粒度锁增加了复杂度，降低了性能&lt;/li&gt;
&lt;li&gt;操作系统限制性能(调度、上下文切换)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对线程支持的不好
&lt;ol&gt;
&lt;li&gt;线程代码难以移植&lt;/li&gt;
&lt;li&gt;标准库非线程安全的&lt;/li&gt;
&lt;li&gt;内核调用，窗口系统不是多线程&lt;/li&gt;
&lt;li&gt;调试工具匮乏&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通常不需要并发&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="替代品"&gt;替代品
&lt;/h2&gt;&lt;p&gt;Events&lt;/p&gt;
&lt;h2 id="主张"&gt;主张
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大多数情况下，事件更好&lt;/li&gt;
&lt;li&gt;只有在真正需要CPU并发的时候，线程才需要&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="event-driven-programming"&gt;Event-Driven Programming
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1个执行流:无CPU并发。&lt;/li&gt;
&lt;li&gt;注册事件回调&lt;/li&gt;
&lt;li&gt;事件循环等待事件，调用处理程序&lt;/li&gt;
&lt;li&gt;不抢占事件处理程序&lt;/li&gt;
&lt;li&gt;handler通常生命周期很短&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="难用的地方"&gt;难用的地方
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;长时间运行的环节使应用程序无响应
&lt;ol&gt;
&lt;li&gt;fork 子进程，用事件在完成时唤醒&lt;/li&gt;
&lt;li&gt;拆分handlers&lt;/li&gt;
&lt;li&gt;在处理程序中定期调用事件循环（重入性增加了复杂性）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;不能跨事件维持本地状态（处理程序必须return）&lt;/li&gt;
&lt;li&gt;没有CPU并发（不适合科学应用）&lt;/li&gt;
&lt;li&gt;事件驱动的I/O并不总是得到很好的支持（例如差劲的写缓冲）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="events-vs-threads"&gt;Events vs. Threads
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;事件尽可能避免并发，线程相反：
&lt;ol&gt;
&lt;li&gt;事件易于上手：无并发、无抢占、无同步、无死锁。&lt;/li&gt;
&lt;li&gt;仅在不寻常的情况下使用复杂的技术。&lt;/li&gt;
&lt;li&gt;使用线程，即使是最简单的应用程序也面临着很大的复杂性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用事件更容易调试
&lt;ol&gt;
&lt;li&gt;时序依赖只与事件相关，与事件内部调度无关&lt;/li&gt;
&lt;li&gt;更容易追踪的问题：按钮响应缓慢 vs 损坏的内存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;单CPU上事件驱动更快
&lt;ol&gt;
&lt;li&gt;没有锁的开销&lt;/li&gt;
&lt;li&gt;没有上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;事件的可以执行更强&lt;/li&gt;
&lt;li&gt;线程提供真正的并发
&lt;ol&gt;
&lt;li&gt;可以使用长时间运行的有状态处理程序而不会冻结&lt;/li&gt;
&lt;li&gt;可扩展的多cpu性能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="应该用线程吗no"&gt;应该用线程吗：NO！
&lt;/h1&gt;&lt;p&gt;尽可能避免线程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于gui、分布式系统、低端服务器，应该使用事件，而不是线程&lt;/li&gt;
&lt;li&gt;只使用真正需要CPU并发的线程&lt;/li&gt;
&lt;li&gt;在需要线程的地方，在线程应用程序内核中隔离使用:保持大多数代码是单线程的&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="conclusions"&gt;Conclusions
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;并发从根本上来说很难;尽可能的避免。&lt;/li&gt;
&lt;li&gt;线程比事件更强大，但很少需要这种能力&lt;/li&gt;
&lt;li&gt;线程比事件更难编程;仅供专家&lt;/li&gt;
&lt;li&gt;使用事件作为主要的开发工具(gui和分布式系统)&lt;/li&gt;
&lt;li&gt;只对性能关键的内核使用线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="ref"&gt;Ref
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ref: &lt;a class="link" href="https://www.cc.gatech.edu/classes/AY2010/cs4210_fall/papers/ousterhout-threads.pdf" target="_blank" rel="noopener"
&gt;Why Threads Are a Bad Idea&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description></item><item><title>Code without TheadPool</title><link>https://MyLoveES.github.io/p/code-without-theadpool/</link><pubDate>Thu, 25 Nov 2021 18:40:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/code-without-theadpool/</guid><description>&lt;h1 id="脱离线程池这些操作的替代方案"&gt;脱离线程池，这些操作的替代方案
&lt;/h1&gt;&lt;h2 id="线程池---优"&gt;线程池 - 优
&lt;/h2&gt;&lt;h2 id="线程池---缺"&gt;线程池 - 缺
&lt;/h2&gt;&lt;h2 id="方案"&gt;方案
&lt;/h2&gt;&lt;h3 id="1-非阻塞"&gt;1. 非阻塞
&lt;/h3&gt;&lt;h3 id="2-限流"&gt;2. 限流
&lt;/h3&gt;&lt;h3 id="3-隔离"&gt;3. 隔离
&lt;/h3&gt;&lt;h3 id="4-任务状态监控干预"&gt;4. 任务状态监控、干预
&lt;/h3&gt;</description></item></channel></rss>