<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>理论 on Kunkka</title><link>https://MyLoveES.github.io/tags/%E7%90%86%E8%AE%BA/</link><description>Recent content in 理论 on Kunkka</description><generator>Hugo -- gohugo.io</generator><language>en</language><lastBuildDate>Thu, 11 Aug 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://MyLoveES.github.io/tags/%E7%90%86%E8%AE%BA/index.xml" rel="self" type="application/rss+xml"/><item><title>Reaching agreement in the presence of faults</title><link>https://MyLoveES.github.io/p/reaching-agreement-in-the-presence-of-faults/</link><pubDate>Thu, 11 Aug 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/reaching-agreement-in-the-presence-of-faults/</guid><description>&lt;h1 id="q处理器进程或者节点各自独立如何才能够达成共识"&gt;Q：处理器、进程或者节点各自独立，如何才能够达成共识？
&lt;/h1&gt;&lt;p&gt;一般情况下，节点间可以彼此传递消息达成一致。但是有故障节点存在的是时候，故障节点可能会向其他节点发送一个错误值，或者发送一些随即值，甚至不发送，导致每个处理器获取到不同的数据，最终计算出不一致的结果。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;比如，处理器间的时钟同步，集群服务器间的数据同步
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;p&gt;Reaching Agreement in the Presence of Faults 论文作者提出一种方法来消除错误处理器的影响 - 通过使用循环多轮的信息交换方案来处理;这样的方案可能会迫使有错误的处理器暴露自己有错误，或者至少使其行为与没有错误的处理器保持一致，从而使后者能够达成一致(当然，是在一定的条件下)。&lt;/p&gt;
&lt;h1 id="assumptions"&gt;Assumptions
&lt;/h1&gt;&lt;p&gt;假设总共有n个独立节点，其中错误节点m个，并且不知道具体是哪些节点出现了问题。节点之间只能双方彼此通信，并且假设数据传输是有保障的并且无延迟。接收方可以识别消息的发出者。&lt;br&gt;
每个节点n具有私有值Vn（可以理解为当前该节点的状态，比如负载等）。对于给定的m、n，通过彼此间的信息交换，让每个节点持有一个所有节点私有值的向量。最终达成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;非故障节点能够计算得到完全相同的向量;&lt;/li&gt;
&lt;li&gt;该向量中，非错误节点的所对应的元素元素，是该节点的私有值&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger1.png finger1 %}&lt;/p&gt;
&lt;h2 id="交互一致性"&gt;交互一致性
&lt;/h2&gt;&lt;p&gt;虽然我们不需要最终知道哪些节点是有问题的，与错误节点对应的向量元素也可以是任意的;但是正确节点对于错误节点的向量元素必须是一致的。&lt;/p&gt;
&lt;p&gt;比如下面的这种情况是不被接受的：
{% asset_img ReachAggrement-finger2.png finger2 %}&lt;/p&gt;
&lt;p&gt;正确节点对所有节点(包括有故障的节点)持有的值达成共识，最终得到（交互式）一致性向量。这样，每个节点就能够通过对该向量的计算，继续得到业务上的所需要的值。&lt;/p&gt;
&lt;h1 id="单节点错误"&gt;单节点错误
&lt;/h1&gt;&lt;h2 id="n4-m1"&gt;n=4, m=1
&lt;/h2&gt;&lt;p&gt;首先可以假设 n=4, m=1。进行两轮信息交换：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;各个节点先把自己的私有值发给其他节点&lt;/li&gt;
&lt;li&gt;各个节点彼此交换第一轮收到的信息&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在信息交换过程中，错误节点可能会发出错误的值，或者不发出任何值，来干扰其他正常节点的计算。对于一个正常节点，如果没有收到节点N的消息，会将其置为默认值（假设为NULL）。&lt;/p&gt;
&lt;p&gt;STEP1:&lt;br&gt;
{% asset_img ReachAggrement-finger3.png finger3 %}
STEP2:&lt;br&gt;
{% asset_img ReachAggrement-finger4.png finger4 %}&lt;/p&gt;
&lt;p&gt;在两轮信息交换完成后，每个节点都会持有“一组”向量值元素。节点可以选取“多数”作为认可的元素值，形成最终的向量。
{% asset_img ReachAggrement-finger5.png finger5 %}&lt;/p&gt;
&lt;h1 id="多节点错误"&gt;多节点错误
&lt;/h1&gt;&lt;p&gt;仅仅两轮信息交换不足以达成共识：&lt;/p&gt;
&lt;p&gt;STEP1:&lt;br&gt;
{% asset_img ReachAggrement-finger6.png finger6 %}&lt;/p&gt;
&lt;p&gt;STEP2:&lt;br&gt;
{% asset_img ReachAggrement-finger7.png finger7 %}&lt;/p&gt;
&lt;p&gt;Finally:&lt;br&gt;
{% asset_img ReachAggrement-finger8.png finger8 %}&lt;/p&gt;
&lt;p&gt;继续下一轮交换信息&amp;hellip;&amp;hellip;..&lt;/p&gt;
&lt;p&gt;m+1 轮后：&lt;/p&gt;
&lt;center&gt;P: 节点集合&lt;/center&gt;
&lt;center&gt;V: 值的集合&lt;/center&gt;
&lt;p&gt;定义：&lt;br&gt;
1）w=p1p2p3&amp;hellip;.pr, σ(w) 意为 pr -&amp;gt; p(r-1) -&amp;gt; p(r-2) -&amp;gt; ··· -&amp;gt; p2 -&amp;gt; p1，Vpr最终流转到p1的结果。&lt;br&gt;
2）对于一个单节点，σ(p) = Vp&lt;br&gt;
3）如果一个节点q是正常的，那么他一定满足：对于任意的集合组成的字串w和任意节点p，&lt;/p&gt;
&lt;center&gt;σ(pqw) = σ(qw)&lt;/center&gt;
同理如果一个集合全部是正常节点，那么集合所组成的字串 w=p1p2p3...pr，和一个任意节点p', 一定能够满足
&lt;center&gt;σ(pwp') = σ(wp')&lt;/center&gt;
&lt;p&gt;那么，通过如下方法帮助p节点得到q值（总节点n，错误节点m，n&amp;gt;=3m+1）：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于集合P的某个大小超过(n+m)/2的子集Q，σp(pwq) = v 对于每个长度不大于m的字串w（取自Q）都成立，那么p记录下v；&lt;/li&gt;
&lt;li&gt;否则，算法将递归应用m-1，n-1，使P-{q}来替代P，并且对于每个长度不大于m的字串w（取自于P-{q}）&lt;/li&gt;
&lt;/ol&gt;
&lt;center&gt;σp'(pw) = σp(pwq)&lt;/center&gt;
如果在这向量n-1个元素里有至少(n+m)/2个元素值相同，p记录下该值，否则记录NIL值。
&lt;p&gt;step1：（目的是确定源节点q正确与否）一定能够找到一个全部是正常节点的集合Q(size &amp;lt;= m)，使得正常的源节点q的值，经过Q处理后，依然不变。
{% asset_img ReachAggrement-finger9.png finger9 %}&lt;/p&gt;
&lt;p&gt;step2：（目的是对错误节点的值达成共识）如果源节点q没能满足step1，说明q在乱发值，q是一个问题节点。&lt;/p&gt;
&lt;p&gt;q向d发送X：
{% asset_img ReachAggrement-finger10.png finger10 %}&lt;/p&gt;
&lt;p&gt;q向e发送Y：
{% asset_img ReachAggrement-finger11.png finger11 %}&lt;/p&gt;
&lt;p&gt;所以q的值是多少不重要了，重要的是其他节点要对q的值达成共识。做法，把问题节点q踢出去，询问其他节点，在他们眼里，q是多少。如果某个值Vq&amp;rsquo;超过半数认可，那么就以Vq&amp;rsquo;作为q的值，否则，记默认值NIL。即：&lt;/p&gt;
&lt;center&gt;σp'(pw) = σp'(pwq') = σp(pwq'q) = σp(pwq)&lt;/center&gt;
&lt;p&gt;p 问q&amp;rsquo;（中间也经过了step1的处理），你眼里q是多少？如果获得了不一致的答案，说明q&amp;rsquo;也有问题，踢了，再问其他节点，最终得到一个正常节点认可的值Vq'1&lt;br&gt;
最终，p得到了其他所有正常节点眼里的q值: Vq'1 Vq'2 &amp;hellip;.. Vq&amp;rsquo;k，如果在这中间，某个值Vq&amp;rsquo;m超过了半数，那么以Vq&amp;rsquo;m作为q的值，否值取默认值NIL。&lt;br&gt;
这个过程就像是询问“认可值”，只要获得了足够多的“认可”，就可视Vq为q的值。&lt;/p&gt;
&lt;h2 id="n7-m2"&gt;n=7, m=2
&lt;/h2&gt;&lt;p&gt;以A为主视角&lt;/p&gt;
&lt;h3 id="step1-每个节点把自己的值发送给其他节点"&gt;step1: 每个节点把自己的值发送给其他节点
&lt;/h3&gt;&lt;p&gt;{% asset_img ReachAggrement-finger12.png finger12 %}&lt;/p&gt;
&lt;h3 id="step2-每个节点分享上一轮接收到的值"&gt;step2: 每个节点分享上一轮接收到的值
&lt;/h3&gt;&lt;h3 id="step3-每个节点再次分享上一轮接收到的值"&gt;step3: 每个节点再次分享上一轮接收到的值
&lt;/h3&gt;&lt;p&gt;{% asset_img ReachAggrement-finger13.png finger13 %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个正常节点，经过子集Q，抵达A的值不会变&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger14.png finger14 %}&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于一个非正常节点，经过子集Q，抵达A的值可能会变。此时需要踢出错误节点，来达成值的一致&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger15.png finger15 %}&lt;/p&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger16.png finger16 %}&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;p&gt;拜占庭国王放下手中的 Reaching_agreement_in_the_presence_of_faults.pdf，陷入沉思。&lt;/p&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger17.png finger17 %}&lt;/p&gt;
&lt;p&gt;最近他的军队正在攻打敌方同样强大的城池，需要将领们协同一致才可制胜。而他也知道，将军们中间有叛徒，正因此进攻才耽搁许久。忽然他眉头一皱，计上心来！&lt;/p&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger18.png finger18 %}&lt;/p&gt;
&lt;p&gt;国王究竟想到了什么办法呢？请看下回：&lt;/p&gt;
&lt;p&gt;{% asset_img ReachAggrement-finger19.png finger19 %}&lt;/p&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;hr&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;回想一下，上一节给出的过程需要两轮信息交换，第一轮“我的私有值是”，第二轮“节点x告诉我他的私有值是....”。在m个节点故障的一般情况下，需要m + 1轮通信。为了描述该算法，可以以更通用的方式描述这种消息交换。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&amp;lt;center&amp;gt;P: 节点集合&amp;lt;/center&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&amp;lt;center&amp;gt;V: 值的集合&amp;lt;/center&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;对于 k&amp;gt;=1. 定义k-scenario为从非空字符串（可能含有重复）P(length &amp;lt;= k+1) 映射到 V。对于一个给出的k-level scenario σ 和字符串 w= p1p2...pr, 2&amp;lt;=r&amp;lt;=k+1, σ(w) 意为 pr-\&amp;gt;p(r-1)-\&amp;gt;p(r-2)-&amp;gt;···-\&amp;gt;p2-\&amp;gt;p1, 【pr 的私有值】。对于一个单一元素的字符串p，σp指代p的私有值Vp。一个k-level scenario 总结了k轮信息交换的结果。(请注意，如果一个错误的节点伪造其他节点给它的信息，这就相当于对给它的值造假。)对于一个正常节点子集，只有可能是确定的映射：尤其是，一个正常节点在传递消息时总是诚实的，所以对于一个正常节点q，任意节点p，以及字符串w来说，一个scenario一定满足：（也就是传递到q的字符串会原封不动地传达给p）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&amp;lt;center&amp;gt;σ(pqw) = σ(qw)&amp;lt;/center&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;节点p在scenario σ接收的消息由σp对以p开头的字符串的限制操作给出(这句话好难理解，我感觉是在表达，secnario σ 是给来源字串加了一个p头)。现在我们要描述，对于任意m&amp;gt;=0,n&amp;gt;=3m+1, 计算p的过程。对于一个给定的σp, 其中交互一致性向量的元素对应着每个节点p。计算过程如下：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1. 对于P的某个大小&amp;gt;(n+m)/2的子集Q，σp(pwq) = v 对于每个长度&amp;lt;=m的字串w（取自Q）都成立，那么p记录下v；
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2. 否则，算法将递归应用m-1，n-1，使P-{q}来替代P，并且对于每个长度不大于m的字串w（取自于P-{q}）
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&amp;lt;center&amp;gt;σp&amp;#39;(pw) = σp(pwq)&amp;lt;/center&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;如果在这向量n-1个元素里有至少(n+m)/2个元素值相同，p记录下该值，否则记录NIL值。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;σp&amp;#39;反应了m-level σ的子场景，其中q被排除在外，并且在σp&amp;#39;每个节点的私有值是它直接从σ中的q获得的值。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;通过对m进行约简，证明上述算法确实保证了交互一致性:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Basis m=0。此时没有节点是错误的，算法总是在第一步结束。p记录Vq为q的私有值；
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Induction Step m&amp;gt;0. 如果q是正常节点，对于来自于正常节点集合的，长度不大于m的字串w（包括空串），σp(pwq)=Vq。这个集合包含了n-m个成员，多于(n+m)/2，满足了条件1. 此外，满足这些要求的任何其他集合必然包含一个正常节点, 因为集合数量大于(n+m)/2，而n&amp;gt;=3m+1. 因此也必然得到Vq作为可用值。因此算法在第(1)步终止，p按要求记录Vq为q的私有值。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;现在假设q是错误的。我们必须表明p记录下的q私有值Vq和其他正常节点一致。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;首先考虑这种情况：p和其他节点p&amp;#39;都在step1结束，他们都找到了一个合适的集合Q。由于每个集合都包含有(n+m)/2个成员，并且由于P总共只有n个成员，两个集合必须有超过2((n + m)/2) - n = m个公共成员。因为其中至少有一个必须是正常的节点，所以这两个集合必须产生相同的值v。
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;接下来我们假设p&amp;#39;在step1退出了，找到了合适的集合Q以及值v，并且p执行step2.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;</description></item><item><title>拜占庭将军 - 包含恶意节点的共识问题</title><link>https://MyLoveES.github.io/p/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B-%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E8%AF%86%E9%97%AE%E9%A2%98/</link><pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B-%E5%8C%85%E5%90%AB%E6%81%B6%E6%84%8F%E8%8A%82%E7%82%B9%E7%9A%84%E5%85%B1%E8%AF%86%E9%97%AE%E9%A2%98/</guid><description>&lt;h1 id="byzantine-generals-problem"&gt;Byzantine Generals Problem
&lt;/h1&gt;&lt;p&gt;一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。&lt;/p&gt;
&lt;p&gt;系统的问题在于，可能将军中出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。假设有9位将军投票，其中1名叛徒。8名忠诚的将军中出现了4人投进攻，4人投撤离的情况。这时候叛徒可能故意给4名投进攻的将领送信表示投票进攻，而给4名投撤离的将领送信表示投撤离。这样一来在4名投进攻的将领看来，投票结果是5人投进攻，从而发起进攻；而在4名投撤离的将军看来则是5人投撤离。这样各支军队的一致协同就遭到了破坏。&lt;/p&gt;
&lt;p&gt;由于将军之间需要通过信使通讯，叛变将军可能通过伪造信件来以其他将军的身份发送假投票。而即使在保证所有将军忠诚的情况下，也不能排除信使被敌人截杀，甚至被敌人间谍替换等情况。因此很难通过保证人员可靠性及通讯可靠性来解决问题。&lt;/p&gt;
&lt;p&gt;假使那些忠诚（或是没有出错）的将军仍然能通过多数决定来决定他们的战略，便称达到了拜占庭容错。在此，票都会有一个预设值，若讯息（票）没有被收到，则使用此预设值来投票。&lt;/p&gt;
&lt;p&gt;上述的故事对映到计算机系统里，将军便成了计算机，而信差就是通讯系统。虽然上述的问题涉及了电子化的决策支援与资讯安全，却没办法单纯的用密码学与数位签章来解决。因为电路错误仍可能影响整个加密过程，这不是密码学与数位签章演算法在解决的问题。因此计算机就有可能将错误的结果送出去，亦可能导致错误的决策。&lt;/p&gt;</description></item><item><title>拜占庭将军 - 论文翻译</title><link>https://MyLoveES.github.io/p/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</link><pubDate>Mon, 11 Jul 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/%E6%8B%9C%E5%8D%A0%E5%BA%AD%E5%B0%86%E5%86%9B-%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/</guid><description>&lt;h1 id="introduction"&gt;INTRODUCTION
&lt;/h1&gt;&lt;p&gt;A reliable computer system must be able to cope with the failure of one or more of its components. A failed component may exhibit a type of behavior that is often overlooked&amp;ndash;namely, sending conflicting information to different parts of the system. The problem of coping with this type of failure is expressed abstractly as the Byzantine Generals Problem. We devote the major part of the paper to a discussion of this abstract problem and conclude by indicating how our solutions can be used in implementing a reliable computer system. We imagine that several divisions of the Byzantine army are camped outside an enemy city, each division commanded by its own general. The generals can communicate with one another only by messenger. After observing the enemy, they must decide upon a common plan of action. However, some of the generals may be traitors, trying to prevent the loyal generals from reaching agreement. The generals must have an algorithm to guarantee that&lt;/p&gt;
&lt;p&gt;一个可靠的计算机系统必须能够应付它的一个或多个部件的故障。一个失败的组件可能会表现出一种经常被忽略的行为——即，向系统的不同部分发送冲突的信息。应对这种类型的失败的问题被抽象地表达为拜占庭将军问题。我们将论文的主要部分用于讨论这一抽象问题，并通过表明我们的解决方案可以用于实现一个可靠的计算机系统。我们想象一下，拜占庭军队的几个师在敌人的城市外扎营，每个师由自己的将军指挥。将军们只能通过信使相互联系。在观察敌人之后，他们必须决定一个共同的行动计划。然而，有些将军可能是叛徒，试图阻止忠诚的将军达成协议。将军们肯定有算法来保证:&lt;/p&gt;
&lt;p&gt;A. All loyal generals decide upon the same plan of action.
The loyal generals will all do what the algorithm says they should, but the traitors may do anything they wish. The algorithm must guarantee condition A regardless of what the traitors do. The loyal generals should not only reach agreement, but should agree upon a reasonable plan. We therefore also want to insure that.&lt;/p&gt;
&lt;h2 id="a-所有忠诚的将军都决定相同的行动计划"&gt;A. 所有忠诚的将军都决定相同的行动计划。
&lt;/h2&gt;&lt;p&gt;忠诚的将军都会按照算法的要求行事，而叛徒则可以随心所欲。算法必须保证不管叛徒做了什么, 所有忠诚的将军都决定相同的行动计划。忠诚的将军们不仅要达成一致，而且要商定一个合理的计划。因此，我们也希望确保这一点&lt;/p&gt;
&lt;h2 id="b-a-small-number-of-traitors-cannot-cause-the-loyal-generals-to-adopt-a-bad-plan"&gt;B. A small number of traitors cannot cause the loyal generals to adopt a bad plan.
&lt;/h2&gt;&lt;p&gt;B. 少数叛徒不能使忠诚的将军采取错误的计划。&lt;/p&gt;
&lt;p&gt;Condition B is hard to formalize, since it requires saying precisely what a bad plan is, and we do not attempt to do so. Instead, we consider how the generals reach a decision. Each general observes the enemy and communicates his observations to the others. Let v(i) be the information communicated by the ith general. Each general uses some method for combining the values v (1) &amp;hellip;.. v(n) into a single plan of action, where n is the number of generals. Condition A is achieved by having all generals use the same method for combining the information, and Condition B is achieved by using a robust method. For example, if the only decision to be made is whether to attack or retreat, then v(i) con be General i&amp;rsquo;s opinion of which option is best, and the final decision can be based upon a majority vote among them. A small number of traitors can affect the decision only if the loyal generals were almost equally divided between the two possibilities, in which case neither decision could be called bad. While this approach may not be the only way to satisfy conditions A and B, it is the only one we know of. It assumes a method by which the generals communicate their values v (i) to one another. The obvious method is for the ith general to send v (i) by messenger to each other general. However, this does not work, because satisfying condition A requires that every loyal general obtain the same values v(1) &amp;hellip;.. v(n), and a traitorous general may send different values to different generals. For condition A to be satisfied, the following must be true:&lt;/p&gt;
&lt;p&gt;条件B很难去具象化，因为它需要准确地说清楚错误的计划是什么，我们不打算去具体描述它。相反，我们考虑将军们如何达成这个共识。每个将军观察敌人并且和其他人沟通他的观察结果。设v(i)是将军i所传达的信息，每个将军使用一些方法来让v(1)~v(n)形成一个具体的行动。条件A是通过让所有的将军使用相同的方法来组合信息来实现的，条件B是通过使用鲁棒的方法来实现的。比如，如果决策是去进攻或者撤退，v(i)是将军i认为最佳的选项，最终结论可以通过他们的多数投票决定。只有当忠诚的将领几乎平分两种可能性时，少数叛徒才能影响决策，在这种情况下，任何一个决策都不能被称为错误的决定。虽然这种方法可能不是满足条件A和B的唯一方法，但它是我们所知道的唯一方法。它假定了一种方法，通过这种方法，将军们互相传达他们的价值观v (i)。最明显的方法是第i个将军通过信使发送v (i)给其他将军。然而，这是行不通的，因为满足条件A要求每个忠诚的将军都获得相同的值v(1) &amp;hellip;..V (n)，一个叛变的将军可能会向不同的将军传达不同的价值观。要满足条件A，必须满足以下条件:&lt;/p&gt;
&lt;h3 id="1-every-loyal-general-must-obtain-the-same-information-v-1---v-n"&gt;1) Every loyal general must obtain the same information v (1) &amp;hellip;. , v (n).
&lt;/h3&gt;&lt;p&gt;Condition 1 implies that a general cannot necessarily use a value of v(i) obtained directly from the ith general, since a traitorous ith general may send different values to different generals. This means that unless we are careful, in meeting condition 1 we might introduce the possibility that the generals use a value of v (i) different from the one sent by the ith general&amp;ndash;even though the ith general is loyal. We must not allow this to happen if condition B is to be met. For example, we cannot permit a few traitors to cause the loya generals to base their decision upon the values &amp;ldquo;retreat&amp;rdquo;,&amp;hellip;, &amp;ldquo;retreat&amp;rdquo; if every loyal general sent the value &amp;ldquo;attack&amp;rdquo;. We therefore have the following requirement for each i:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每个忠诚的将军必须获得相同的信息v (1) &amp;hellip;.， v(n)。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;条件1表明，将军不能使用直接从第i个将军处获得的v(i)的值，因为叛变的第i个将军可能会向不同的将军发送不同的值。这意味着，除非我们很小心，在满足条件1时，我们可能会引入这样一种可能性:将军使用的v (i)值与第i个将军发送的值不同——即使第i个将军是忠诚的。如果要满足条件B，我们决不能允许这种情况发生。例如，我们不能允许少数叛徒使忠诚将军们根据 “retreat”&amp;hellip;..&amp;ldquo;retreat&amp;rdquo; 的价值观作出决定，如果每一个忠诚的将军都发出“进攻”的指令。因此，我们对每个i有以下要求:&lt;/p&gt;
&lt;h3 id="2-if-the-ith-general-is-loyal-then-the-value-that-he-sends-must-be-used-by-every-loyal-general-as-the-value-of-v-i"&gt;2) If the ith general is loyal, then the value that he sends must be used by every loyal general as the value of v (i).
&lt;/h3&gt;&lt;ol start="2"&gt;
&lt;li&gt;如果第i个将军是忠诚的，那么他发送的值必须被每个忠诚的将军用作v (i)的值。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We can rewrite condition I as the condition that for every i (whether or not the ith general is loyal):&lt;/p&gt;
&lt;p&gt;1&amp;rsquo;. Any two loyal generals use the same value of v(i).&lt;br&gt;
Conditions 1&amp;rsquo; and 2 are both conditions on the single value sent by the ith general. We can therefore restrict our consideration to the problem of how a single general sends his value to the others. We phrase this in terms of a commanding general sending an order to his lieutenants, obtaining the following problem. Byzantine Generals Problem. A commanding general must send an order to his n - 1 lieutenant generals such that&lt;/p&gt;
&lt;p&gt;条件1&amp;rsquo;和2都是第i个将军发送的单个值的条件。因此，我们可以把我们的考虑限制在一个将军如何把他的值传递给其他人的问题上。我们用一个将军向他的副手们发出命令的方式来表述这个问题，得到了下面的问题。拜占庭将军的问题。一位指挥官必须向他的n - 1名中将发出这样的命令:&lt;/p&gt;
&lt;h4 id="ic1-all-loyal-lieutenants-obey-the-same-order"&gt;IC1. All loyal lieutenants obey the same order.
&lt;/h4&gt;&lt;h4 id="ic2-if-the-commanding-general-is-loyal-then-every-loyal-lieutenant-obeys-the-order-he-sends"&gt;IC2. If the commanding general is loyal, then every loyal lieutenant obeys the order he sends.
&lt;/h4&gt;&lt;p&gt;IC1。所有忠诚的中尉都服从同一条命令。
IC2。如果指挥官是忠诚的，那么每个忠诚的中尉都会服从他的命令。&lt;/p&gt;
&lt;p&gt;Conditions IC1 and IC2 are called the interactive consistency conditions. Note that if the commander is loyal, then IC1 follows from IC2. However, the commander need not be loyal. To solve our original problem, the ith general sends his value of v(i) by using a solution to the Byzantine Generals Problem to send the order &amp;ldquo;use v (i) as my value&amp;rdquo;, with the other generals acting as the lieutenants.&lt;/p&gt;
&lt;p&gt;IC1和IC2称为交互一致性条件。注意，如果指挥官是忠诚的，IC1包含于IC2。但是指挥官不一定是忠诚的。为了解决我们最初的问题，第i个将军发出他的值v(i)，通过使用拜占庭将军问题的一个解决方案，发送命令“使用v(i)作为我的值”，其他将军充当中尉。&lt;/p&gt;
&lt;h2 id="2-impossibility-results"&gt;2. IMPOSSIBILITY RESULTS
&lt;/h2&gt;&lt;ol start="2"&gt;
&lt;li&gt;不可能的结果&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The Byzantine Generals Problem seems deceptively simple. Its difficulty is indicated by the surprising fact that if the generals can send only oral messages, then no solution will work unless more than two-thirds of the generals are loyal. In particular, with only three generals, no solution can work in the presence of a single traitor. An oral message is one whose contents are completely under the control of the sender, so a traitorous sender can transmit any possible message. Such a message corresponds to the type of message that computers normally send to one another. In Section 4 we consider signed, written messages, for which this is not true.&lt;/p&gt;
&lt;p&gt;We now show that with oral messages no solution for three generals can handle a single traitor. For simplicity, we consider the case in which the only possible decisions are &amp;ldquo;attack&amp;rdquo; or &amp;ldquo;retreat&amp;rdquo;. Let us first examine the scenario pictured in Figure 1 in which the commander is loyal and sends an &amp;ldquo;attack&amp;rdquo; order, but Lieutenant 2 is a traitor and reports to Lieutenant 1 that he received a &amp;ldquo;retreat&amp;rdquo; order. For IC2 to be satisfied, Lieutenant 1 must obey the order to attack.&lt;/p&gt;
&lt;p&gt;Now consider another scenario, shown in Figure 2, in which the commander is a traitor and sends an &amp;ldquo;attack&amp;rdquo; order to Lieutenant 1 and a &amp;ldquo;retreat&amp;rdquo; order to Lieutenant 2. Lieutenant 1 does not know who the traitor is, and he cannot tell what message the commander actually sent to Lieutenant 2. Hence, the scenarios in these two pictures appear exactly the same to Lieutenant 1. If the traitor lies consistently, then there is no way for Lieutenant 1 to distinguish between these two situations, so he must obey the &amp;ldquo;attack&amp;rdquo; order in both of them. Hence, whenever Lieutenant 1 receives an &amp;ldquo;attack&amp;rdquo; order from the commander, he must obey it.&lt;/p&gt;
&lt;p&gt;拜占庭将军问题看似简单。他的困难点在于，如果将军们只能口头传递信息，那么除非三分之二的将军是忠诚的，否则不会有解决方案。特别是，只有三个将军，任何解决方案在一个叛徒面前都无法奏效。口头信息的内容完全在发送者的控制之下，所以一个叛国的发送者可以传递任何可能的信息。这种消息对应于计算机通常相互发送的消息类型。在第4节中，我们考虑了签名的书面消息, 对于这样的消息，这是做不到的（指的是签名的书面消息，不会让叛徒随意传递消息）。&lt;/p&gt;
&lt;p&gt;我们现在证明，通过口头消息，三个将军的解决方案对付不了一个叛徒。让我们先来看看图1所示的场景:指挥官很忠诚，发出了“攻击”命令，但中尉2是叛徒，他向中尉1报告他收到了“撤退”命令。为了使IC2满意，中尉1必须服从攻击命令。&lt;/p&gt;
&lt;p&gt;现在考虑另一种场景，如图2所示，其中指挥官是叛徒，向中尉1发送“攻击”命令，向中尉2发送“撤退”命令。中尉1不知道叛徒是谁，他也不知道指挥官到底给中尉2发了什么信息。因此，在中尉1看来，这两幅图中的场景是完全相同的。如果叛徒一直说谎，那么中尉1就没有办法区分这两种情况，所以他必须在两种情况下都服从“攻击”命令。因此，每当中尉收到指挥官的“攻击”命令时，他必须遵守。&lt;/p&gt;
&lt;p&gt;However, a similar argument shows that if Lieutenant 2 receives a &amp;ldquo;retreat&amp;rdquo; order from the commander then he must obey it even if Lieutenant 1 tells him that the commander said &amp;ldquo;attack&amp;rdquo;. Therefore, in the scenario of Figure 2, Lieutenant 2 must obey the &amp;ldquo;retreat&amp;rdquo; order while Lieutenant 1 obeys the &amp;ldquo;attack&amp;rdquo; order, thereby violating condition IC1. Hence, no solution exists for three generals that works in the presence of a single traitor.&lt;/p&gt;
&lt;p&gt;This argument may appear convincing, but we strongly advise the reader to be very suspicious of such nonrigorous reasoning. Although this result is indeed correct, we have seen equally plausible &amp;ldquo;proofs&amp;rdquo; of invalid results. We know of no area in computer science or mathematics in which informal reasoning is more likely to lead to errors than in the study of this type of algorithm. For a rigorous proof of the impossibility of a three-general solution that can handle a single traitor, we refer the reader to [3].&lt;/p&gt;
&lt;p&gt;然而，一个类似的论点表明，如果中尉2收到指挥官的“撤退”命令，那么他必须遵守，即使中尉1告诉他指挥官说的是“攻击”。因此，在图2场景中，中尉2必须服从“撤退”命令，而中尉1必须服从“进攻”命令，因此违反了条件IC1。因此，在一个叛徒在场的情况下，三个将军是不存在解决方案的。&lt;/p&gt;
&lt;p&gt;Using this result, we can show that no solution with fewer than 3m + 1 generals can cope with m traitors. The proof is by contradiction&amp;ndash;we assume such a solution for a group of 3m or fewer and use it to construct a three-general solution to the Byzantine Generals Problem that works with one traitor, which we know to be impossible. To avoid confusion between the two algorithms, we call the generals of the assumed solution Albanian generals, and those of the constructed solution Byzantine generals. Thus, starting from an algorithm that allows 3m or fewer Albanian generals to cope with m traitors, we construct a solution that allows three Byzantine generals to handle a single traitor.&lt;/p&gt;
&lt;p&gt;The three-general solution is obtained by having each of the Byzantine generals simulate approximately one-third of the Albanian generals, so that each Byzantine general is simulating at most m Albanian generals. The Byzantine commander simulates the Albanian commander plus at most m - 1 Albanian lieutenants, and each of the two Byzantine lieutenants simulates at most m Albanian lieutenants. Since only one Byzantine general can be a traitor, and he simulates at most m Albanians, at most m of the Albanian generals are traitors. Hence, the assumed solution guarantees that IC1 and IC2 hold for the Albanian generals. By IC1, all the Albanian lieutenants being simulated by a loyal Byzantine lieutenant obey the same order, which is the order he is to obey. It is easy to check that conditions IC1 and IC2 of the Albanian generals solution imply the corresponding conditions for the Byzantine generals, so we have constructed the required impossible solution.&lt;/p&gt;
&lt;p&gt;利用这个结果，我们可以证明，少于3m + 1个将军的解无法应对m个叛徒。证明方法是矛盾的——我们假设这样的解对于3m或更少的一群人来说，并使用它来构建一个适用于三个将军，一个叛徒的拜占庭将军问题，我们知道这是不可能的。为了避免两种算法之间的混淆，我们称假设解的将军为阿尔巴尼亚将军，而称构造解的将军为拜占庭将军。因此，从一个允许3m或更少的阿尔巴尼亚将军对付m个叛徒的算法开始，我们构建了一个允许3个拜占庭将军对付一个叛徒的解决方案。&lt;/p&gt;
&lt;p&gt;三个将军的解决方案是由每个拜占庭将军模拟大约三分之一的阿尔巴尼亚将军得到的，这样每个拜占庭将军最多模拟m个阿尔巴尼亚将军。拜占庭指挥官模拟阿尔巴尼亚指挥官加上最多m - 1个阿尔巴尼亚中尉，两个拜占庭中尉分别模拟最多m个阿尔巴尼亚中尉。因为只有一个拜占庭将军可以是叛徒，而且他最多模拟了m个阿尔巴尼亚人，所以最多m个阿尔巴尼亚将军是叛徒。因此，假定的解决方案保证了IC1和IC2适用于阿尔巴尼亚将军。在IC1中，所有的阿尔巴尼亚中尉都被模拟成一个忠诚的拜占庭中尉，服从同一条命令，这是他必须服从的命令。很容易检查阿尔巴尼亚将军解的条件IC1和IC2意味着对应的拜占庭将军解的条件，因此我们已经构造了所需的不可能解。&lt;/p&gt;
&lt;p&gt;One might think that the difficulty in solving the Byzantine Generals Problem stems from the requirement of reaching exact agreement. We now demonstrate that this is not the case by showing that reaching approximate agreement is just as hard as reaching exact agreement. Let us assume that instead of trying to agree on a precise battle plan, the generals must agree only upon an approximate time of attack. More precisely, we assume that the commander orders the time of the attack, and we require the following two conditions to hold:&lt;/p&gt;
&lt;p&gt;有人可能会认为，解决拜占庭将军问题的困难源于达成确切协议的要求。我们现在通过表明达成近似一致和达成精确一致一样困难来证明，情况并非如此。让我们假设，将领们不必就精确的作战计划达成一致，而只需就大致的进攻时间达成一致。更准确地说，我们假设指挥官下令攻击的时间，我们需要以下两个条件才能维持下去:&lt;/p&gt;
&lt;p&gt;IC1 &amp;lsquo;. All loyal lieutenants attack within 10 minutes of one another.
IC2&amp;rsquo;. If the commanding general is loyal, then every loyal lieutenant attacks within 10 minutes of the time given in the commander&amp;rsquo;s order.&lt;/p&gt;
&lt;h3 id="ic1所有忠诚的中尉都在十分钟内互相攻击"&gt;IC1”。所有忠诚的中尉都在十分钟内互相攻击。
&lt;/h3&gt;&lt;h3 id="ic2如果指挥官是忠诚的那么每个忠诚的中尉在指挥官命令的10分钟内攻击"&gt;IC2”。如果指挥官是忠诚的，那么每个忠诚的中尉在指挥官命令的10分钟内攻击。
&lt;/h3&gt;&lt;p&gt;(We assume that the orders are given and processed the day before the attack and that the time at which an order is received is irrelevant&amp;ndash;only the attack time given in the order matters.}&lt;/p&gt;
&lt;p&gt;(我们假设命令是在攻击发生的前一天发出并处理的，而接收到命令的时间是无关紧要的——只有命令中给出的攻击时间是重要的。)&lt;/p&gt;
&lt;p&gt;Like the Byzantine Generals Problem, this problem is unsolvable unless more than two-thirds of the generals are loyal. We prove this by first showing that if there were a solution for three generals that coped with one traitor, then we could construct a three-general solution to the Byzantine Generals Problem that also worked in the presence of one traitor. Suppose the commander wishes to send an &amp;ldquo;attack&amp;rdquo; or &amp;ldquo;retreat&amp;rdquo; order. He orders an attack by sending an attack time of 1:00 and orders a retreat by sending an attack time of 2:00, using the assumed algorithm. Each lieutenant uses the following procedure to obtain his order.&lt;/p&gt;
&lt;p&gt;就像拜占庭将军问题一样，这个问题是无法解决的，除非超过三分之二的将军是忠诚的。我们首先证明，如果有一个解决方案，可以解决三个将军同时对付一个叛徒，那么我们就可以构建一个解决三将军一叛徒的拜占庭将军问题。假设指挥官想要发出“进攻”或“撤退”的命令。他通过发送1点的攻击时间来命令攻击，通过发送2点的攻击时间来命令撤退，使用假设的算法。每个中尉都使用以下程序来获得命令。&lt;/p&gt;
&lt;h4 id="1-after-receiving-the-attack-time-from-the-commander-a-lieutenant-does-one-of-the-following"&gt;(1) After receiving the attack time from the commander, a lieutenant does one of the following:
&lt;/h4&gt;&lt;h5 id="a-if-the-time-is-110-or-earlier-then-attack"&gt;(a) If the time is 1:10 or earlier, then attack.
&lt;/h5&gt;&lt;h5 id="b-if-the-time-is-150-or-later-then-retreat"&gt;(b) If the time is 1:50 or later, then retreat.
&lt;/h5&gt;&lt;h5 id="c-otherwise-continue-to-step-2"&gt;(c) Otherwise, continue to step (2).
&lt;/h5&gt;&lt;h4 id="2-ask-the-other-lieutenant-what-decision-he-reached-in-step-1"&gt;(2) Ask the other lieutenant what decision he reached in step (1).
&lt;/h4&gt;&lt;h5 id="a-if-the-other-lieutenant-reached-a-decision-then-make-the-same-decision-he-did"&gt;(a) If the other lieutenant reached a decision, then make the same decision he did.
&lt;/h5&gt;&lt;h5 id="b-otherwise-retreat"&gt;(b) Otherwise, retreat.
&lt;/h5&gt;&lt;p&gt;It follows from IC2&amp;rsquo; that if the commander is loyal, then a loyal lieutenant will obtain the correct order in step (1), so IC2 is satisfied. If the commander is loyal, then IC1 follows from IC2, so we need only prove IC1 under the assumption that the commander is a traitor. Since there is at most one traitor, this means that both lieutenants are loyal. It follows from ICI&amp;rsquo; that if one lieutenant decides to attack in step (1), then the other cannot decide to retreat in step (1). Hence, either they will both come to the same decision in step (1) or at least one of them will defer his decision until step (2). In this case, it is easy to see that they both arrive at the same decision, so IC1 is satisfied. We have therefore constructed a three-general solution to the Byzantine Generals Problem that handles one traitor, which is impossible. Hence, we cannot have a three-general algorithm that maintains ICI&amp;rsquo; and IC2&amp;rsquo; in the presence of a traitor. The method of having one general simulate m others can now be used to prove that no solution with fewer than 3rn + 1 generals can cope with m traitors. The proof is similar to the one for the original Byzantine Generals Problem and is left to the reader.&lt;/p&gt;
&lt;p&gt;由IC2’可知，如果指挥官是忠诚的，那么忠诚的中尉将在步骤(1)中获得正确的命令，因此IC2是满足的。如果指挥官是忠诚的，那么IC1从IC2继承而来，所以我们只需要在指挥官是叛徒的假设下证明IC1。因为最多有一个叛徒，这意味着两个中尉都是忠诚的。根据ICI&amp;rsquo;可知，如果一个中尉在步骤(1)中决定进攻，那么另一个中尉在步骤(1)中就不能决定撤退。因此，他们要么在步骤(1)中都做出相同的决定，要么至少有一个会推迟到步骤(2)。在这种情况下，很容易看到他们都做出了相同的决定，所以IC1是满意的。因此，我们建立了一个解决三将军，一叛徒的办法，但这是不可能的。因此，我们不能有一个三将军算法，在叛徒存在的情况下保持ICI&amp;rsquo;和IC2&amp;rsquo;。用一个将军模拟m个其他将军模拟的方法现在可以用来证明，没有一个小于3rn + 1个将军的解可以对付m个叛徒。这个证明类似于原来的拜占庭将军问题，留给读者。&lt;/p&gt;
&lt;h2 id="3-a-solution-with-oral-messages"&gt;3. A SOLUTION WITH ORAL MESSAGES
&lt;/h2&gt;&lt;p&gt;3.一个口头信息的解决方案&lt;/p&gt;
&lt;p&gt;We showed above that for a solution to the Byzantine Generals Problem using oral messages to cope with rn traitors, there must be at least 3m + 1 generals. We now give a solution that works for 3m + 1 or more generals. However, we first specify exactly what we mean by &amp;ldquo;oral messages&amp;rdquo;. Each general is supposed to execute some algorithm that involves sending messages to the other generals, and we assume that a loyal general correctly executes his algorithm. The definition of an oral message is embodied in the following assumptions which we make for the generals&amp;rsquo; message system:&lt;/p&gt;
&lt;p&gt;我们在上面展示过，要想解决拜占庭将军问题，用口头信息来对付rn叛徒，至少需要300m + 1名将军。我们现在给出的解决方案适用于3m + 1或更多的将军。然而，我们首先具体说明我们所说的“口头信息”是什么意思。每个将军都应该执行一些算法包括向其他将军发送消息，我们假设一个忠诚的将军正确地执行他的算法。口头信息的定义体现在我们对将军信息系统做出的以下假设:&lt;/p&gt;
&lt;p&gt;A1. Every message that is sent is delivered correctly.&lt;br&gt;
A2. The receiver of a message knows who sent it.&lt;br&gt;
A3. The absence of a message can be detected.&lt;/p&gt;
&lt;p&gt;A1. 发送的每个消息都被正确地传递。 &lt;br&gt;
A2. 消息的接收者知道是谁发送的。&lt;br&gt;
A3. 可以检测到消息的缺失。&lt;br&gt;
Assumptions A1 and A2 prevent a traitor from interfering with the communication between two other generals, since by A1 he cannot interfere with the messages they do send, and by A2 he cannot confuse their intercourse by introducing spurious messages. Assumption A3 will foil a traitor who tries to prevent a decision by simply not sending messages. The practical implementation of these assumptions is discussed in Section 6.&lt;/p&gt;
&lt;p&gt;假设A1和A2可以防止叛徒干扰另外两位将军之间的通信，因为A1不能干扰他们实际发送的信息，而A2不能通过引入虚假信息来混淆他们的通信。假设A3将挫败试图通过不发送消息来阻止决策的叛徒。第6节将讨论这些假设的实际实现。&lt;/p&gt;
&lt;p&gt;The algorithms in this section and in the following one require that each general be able to send messages directly to every other general. In Section 5, we describe algorithms which do not have this requirement.&lt;br&gt;
A traitorous commander may decide not to send any order. Since the lieuten- ants must obey some order, they need some default order to obey in this case. We let RETREAT be this default order.&lt;/p&gt;
&lt;p&gt;本节和下一节中的算法要求每个将军能够直接向其他将军发送消息。在第5节中，我们描述的算法没有这个要求。&lt;br&gt;
叛国的指挥官可以决定不发出任何命令。由于中尉必须服从某些命令，在这种情况下，他们需要一些默认的命令来服从。我们让撤退成为这个默认的命令。&lt;/p&gt;
&lt;p&gt;We inductively define the Oral Message algorithms OM(m), for all nonnegative integers m, by which a commander sends an order to n - 1 lieutenants. We show that OM(m) solves the Byzantine Generals Problem for 3m + 1 or more generals in the presence of at most m traitors. We find it more convenient to describe this algorithm in terms of the lieutenants &amp;ldquo;obtaining a value&amp;rdquo; rather than &amp;ldquo;obeying an order&amp;rdquo;.&lt;/p&gt;
&lt;p&gt;我们归纳地定义了口头消息算法OM(m)，对于所有非负整数m，指挥官通过它向n - 1个中尉发送命令。我们证明OM(m)在最多m个叛徒存在的情况下，解决了3m + 1或更多将军的拜占庭将军问题。我们发现用中尉“获取一个值”来描述这个算法比用“服从一个命令”来描述更方便。&lt;/p&gt;
&lt;p&gt;The algorithm assumes a function majority with the property that if a majority of the values vi equal v, then majority (V1,···, vn-1 equals v. (Actually, it assumes a sequence of such functions&amp;ndash;one for each n.) There are two natural choices for the value of majority(v1, &amp;hellip;, vn-1):&lt;/p&gt;
&lt;p&gt;该算法假设函数具有如下属性:如果大多数值vi等于v，那么大多数(V1,···，vn-1)等于v(实际上，它假设有一个这样的函数序列——每个n对应一个函数)。多数的值有两个自然的选择(v1，…, vn-1):&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;The majority value among the vi if it exists, otherwise the value RETREAT;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;The median of the vi, assuming that they come from an ordered set.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果存在，则为vi中的多数值，否则为RETREAT值；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;vi的中位数，假设它们来自一个有序集合。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;The following algorithm requires only the aforementioned property of majority.&lt;/p&gt;
&lt;p&gt;下面的算法只需要上述的多数属性。&lt;/p&gt;
&lt;p&gt;Algorithm OM(0).&lt;/p&gt;
&lt;p&gt;(1) The commander sends his value to every lieutenant.&lt;br&gt;
(2) Each lieutenant uses the value he receives from the commander, or uses the value RETREAT if he receives no value.&lt;/p&gt;
&lt;p&gt;(1) 指挥官将他的值发送给每个中尉。&lt;br&gt;
(2) 每个中尉使用他从指挥官那里收到的值，如果他没有收到值，则使用RETREAT。&lt;/p&gt;
&lt;p&gt;Algorithm OM(m), m &amp;gt; O.&lt;/p&gt;
&lt;p&gt;(1) The commander sends his value to every lieutenant.&lt;br&gt;
(2) For each i, let vi be the value Lieutenant i receives from the commander, or else be RETREAT if he receives no value. Lieutenant i acts as the commander in Algorithm OM(m - 1) to send the value vi to each of the n - 2 other lieutenants.&lt;br&gt;
(3) For each i, and each j ~ i, let vj be the value Lieutenant i received from Lieutenant j in step (2) (using Algorithm OM(m - 1)), or else RETREAT if he received no such value. Lieutenant i uses the value majority (vl &amp;hellip;.. vn-1).&lt;/p&gt;
&lt;p&gt;(1) 司令员向每一个中尉报信。&lt;br&gt;
(2) 对于每一个i, vi为中尉i从指挥官那里得到的值，否则为撤退，如果他没有得到值。中尉i作为算法OM(m - 1)中的指挥官，将值vi发送给n - 2个其他中尉。&lt;br&gt;
(3) 对于每个i和每个j ~ i，让vj为步骤(2)中中尉i从中尉j处得到的值(使用算法OM(m - 1))，如果没有得到该值则撤退。中尉i使用的值多数(vl &amp;hellip;..vn-1)。&lt;/p&gt;
&lt;p&gt;To understand how this algorithm works, we consider the case m = 1, n = 4. Figure 3 illustrates the messages received by Lieutenant 2 when the commander sends the value v and Lieutenant 3 is a traitor. In the first step of OM(1), the commander sends v to all three lieutenants. In the second step, Lieutenant 1 sends the value v to Lieutenant 2, using the trivial algorithm OM(0). Also in the second step, the traitorous Lieutenant 3 sends Lieutenant 2 some other value x. In step 3, Lieutenant 2 then has v1 = v2 = v and v3 = x, so he obtains the correct value v = majority(v, v, x).&lt;/p&gt;
&lt;p&gt;为了理解这个算法是如何工作的，我们假定 m=1, n=4。图三阐释了，当指挥官发送值v并且当副官3是一名叛徒的时候，副官2接收到的值。第一步OM(1)中，指挥官发送v给所有的副官。第二步，副官1发送v给副官2，使用OM(0)。在第二步，叛徒副官3发送给副官2一些其他值，比如x。第三步，副官2有了v1=v2=v and v3=x，所以它维持了正确的v=majority(v,v,x)。&lt;/p&gt;
&lt;p&gt;Next, we see what happens if the commander is a traitor. Figure 4 shows the values received by the lieutenants if a traitorous commander sends three arbitrary values x, y, and z to the three lieutenants. Each lieutenant obtains v1 = x, v2 = y, and v3 = z, so they all obtain the same value majority(x, y, z) in step (3), regardless of whether or not any of the three values x, y, and z are equal.&lt;/p&gt;
&lt;p&gt;然后，我们再来看如果指挥官是一名叛徒的话，会发生什么。图4展示了副官们接收到的值，当指挥官是叛徒时，他分别发送三个值给三个副官：x,y,z。每个副官保持着v1 = x, v2 = y, and v3 = z，所以他们都保持着相同的majority(x,y,z).&lt;/p&gt;
&lt;p&gt;The recursive algorithm OM(m) invokes n - 1 separate executions of the algorithm OM(m - 1), each of which invokes n - 2 executions of OM(m - 2), etc. This means that, for m &amp;gt; 1, a lieutenant sends many separate messages to each other lieutenant. There must be some way to distinguish among these different messages. The reader can verify that all ambiguity is removed if each lieutenant i prefixes the number i to the value vi that he sends in step (2). As the recursion &amp;ldquo;unfolds,&amp;rdquo; the algorithm OM(m - k) will be called (n - 1) &amp;hellip; (n - k) times to send a value prefixed by a sequence of k lieutenants&amp;rsquo; numbers.&lt;/p&gt;
&lt;p&gt;递归算法OM(m)调用算法OM(m - 1)的n - 1次单独执行，其每次调用OM(m - 2)的n - 2次执行，以此类推。这意味着，对于m&amp;gt;1，一个中尉向其他每个中尉发送了许多单独的信息。必须有某种方法来区分这些不同的信息。读者可以验证，如果每个中尉i在他在步骤(2)中发送的值vi前加上数字i，那么所有的模糊性都会被消除。随着递归“展开”，算法OM(m-k)将被调用 (n - 1) &amp;hellip; (n - k) 次去发送一个前缀是k个副官序号的序列值的value。&lt;/p&gt;
&lt;p&gt;To prove the correctness of the algorithm OM{m) for arbitrary m, we first prove the following lemma.&lt;/p&gt;
&lt;p&gt;为了证明任意m的算法OM(m)的正确性，我们首先要证明以下定理。&lt;/p&gt;
&lt;p&gt;LEMMA 1. For any m and k, Algorithm OM (m ) satisfies IC2 if there are more than 2k + m generals and at most k traitors.&lt;/p&gt;
&lt;p&gt;LEMMA 1. 对于任何m和k，如果有超过2k+m的将军和最多k的叛徒，算法OM（m）满足IC2。&lt;/p&gt;
&lt;p&gt;PROOF. The proof is by induction on m. IC2 only specifies what must happen if the commander is loyal. Using A1, it is easy to see that the trivial algorithm OM(0) works if the commander is loyal, so the lemma is true for m = 0. We now assume it is true for m-1(m&amp;gt;0), and prove it for m.&lt;/p&gt;
&lt;p&gt;In step (1), the loyal commander sends a value v to all n - 1 lieutenants. In step (2), each loyal lieutenant applies OM(m - 1) with n - 1 generals. Since by hypothesis n&amp;gt;2k+m, we have n-1&amp;gt;2k+(m- 1),so we can apply the induction hypothesis to conclude that every loyal lieutenant gets vj = v for each loyal Lieutenant j. Since there are at most k traitors, and n - 1 &amp;gt; 2k + (m - 1) &amp;gt; 2k, a majority of the n - 1 lieutenants are loyal. Hence, each loyal lieutenant has vi = v for a majority of the n - 1 values i, so he obtains majority(v1 &amp;hellip;. , vn-1) = v in step (3), proving IC2.&lt;/p&gt;
&lt;p&gt;证明。证明是通过对m的归纳。IC2只规定了如果指挥官是忠诚的，必须发生什么。利用A1，我们很容易看到，如果指挥官是忠诚的，算法OM(0)是有效的，所以该定理对于m=0来说是真的。&lt;/p&gt;
&lt;p&gt;在步骤（1）中，忠诚的指挥官向所有n-1名中尉发送一个值v。在步骤（2）中，每个忠诚的中尉向n-1个将军应用OM（m - 1）。由于假设n&amp;gt;2k+m，我们有n-1&amp;gt;2k+(m-1),所以我们可以应用归纳假设得出结论：每个忠诚的中尉j得到vj=v。由于最多只有k个叛徒，而n-1&amp;gt;2k+(m-1)&amp;gt;2k，n-1个中尉的大多数是忠诚的。因此，每个忠诚的中尉在n - 1的大多数值i中都有vi = v，所以他在步骤(3)中得到major(v1 &amp;hellip;. , vn-1) = v，证明了IC2。&lt;/p&gt;
&lt;p&gt;The following theorem asserts that Algorithm OM(m) solves the Byzantine Generals Problem.&lt;/p&gt;
&lt;p&gt;以下定理断言，算法OM(m)解决了拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;THEOREM 1. For any m, Algorithm OM (m ) satisfies conditions IC1 and IC2 if there are more than 3m generals and at most m traitors.&lt;/p&gt;
&lt;p&gt;定理1. 对于任何m，如果有超过3m个将军和最多m个叛徒，则算法OM（m ）满足条件IC1和IC2。&lt;/p&gt;
&lt;p&gt;PROOF. The proof is by induction on m. If there are no traitors, then it is easy to see that OM(0) satisfies IC1 and IC2. We therefore assume that the theorem is true for OM(m - 1) and prove it for OM(m), m &amp;gt; 0.&lt;br&gt;
We first consider the case in which the commander is loyal. By taking k equal to m in Lemma 1, we see that OM(m) satisfies IC2. IC1 follows from IC2 if the commander is loyal, so we need only verify IC1 in the case that the commander is a traitor.&lt;br&gt;
There are at most m traitors, and the commander is one of them, so at most m - 1 of the lieutenants are traitors. Since there are more than 3m generals, there are more than 3m - 1 lieutenants, and 3m - 1 &amp;gt; 3(m - 1). We may therefore apply the induction hypothesis to conclude that OM(m - 1) satisfies conditions IC1 and IC2. Hence, for each j, any two loyal lieutenants get the same value for vj in step (3). (This follows from IC2 if one of the two lieutenants is Lieutenant j, and from IC1 Otherwise.) Hence, any two loyal lieutenants get the same vector of values vl &amp;hellip;.. Vn-1, and therefore obtain the same value majority(vl &amp;hellip;.. Vn-1) in step (3), proving IC1.&lt;/p&gt;
&lt;p&gt;证明。如果没有叛徒，那么很容易看出OM(0)满足IC1和IC2。因此，我们假设该定理对OM(m - 1)是真的，并对OM(m)，m&amp;gt;0进行证明。&lt;br&gt;
我们首先考虑司令员是忠诚的情况。通过将k等同于结论1中的m，我们看到OM(m)满足IC2。如果指挥官是忠诚的，IC1由IC2得出，所以我们只需要在指挥官是叛徒的情况下验证IC1。&lt;br&gt;
最多有m个叛徒，而指挥官是其中之一，所以最多有m-1个中尉是叛徒。由于有超过3米的将军，所以有超过3米-1的中尉，而且3米-1&amp;gt;3（米-1）。因此，我们可以运用归纳假设得出结论：OM(m - 1)满足条件IC1和IC2。因此，对于每个j，任何两个忠诚的副手在步骤（3）中得到的vj值都是一样的。(如果两个中尉中的一个是中尉j，这由IC2得出，否则由IC1得出）。因此，任何两个忠诚的中尉都会得到相同的价值向量vl &amp;hellip;.. Vn-1，因此在步骤(3)中获得相同的值 majority(vl &amp;hellip;.. Vn-1)，证明了IC1。&lt;/p&gt;
&lt;h2 id="4-a-solution-with-signed-messages"&gt;4. A SOLUTION WITH SIGNED MESSAGES
&lt;/h2&gt;&lt;p&gt;签名消息方案&lt;/p&gt;
&lt;p&gt;As we saw from the scenario of Figures 1 and 2, it is the traitors&amp;rsquo; ability to lie that makes the Byzantine Generals Problem so difficult. The problem becomes easier to solve if we can restrict that ability. One way to do this is to allow the generals to send unforgeable signed messages. More precisely, we add to A1-A3 the A4&lt;br&gt;
(a) A loyal general&amp;rsquo;s signature cannot be forged, and any alteration of the contents of his signed messages can be detected.&lt;br&gt;
(b) Anyone can verify the authenticity of a general&amp;rsquo;s signature.&lt;/p&gt;
&lt;p&gt;正如我们从图1和图2的情景中看到的那样，正是叛徒的撒谎能力使拜占庭将军问题变得如此困难。如果我们能限制这种能力，问题就会变得更容易解决。做到这一点的一个方法是允许将军们发送不可伪造的签名信息。更确切地说，我们在A1-A3中加入A4&lt;br&gt;
(a) 忠诚的将军的签名不能被伪造，任何对其签名信息内容的篡改都能被发现。&lt;br&gt;
(b) 任何人都可以验证一个将军的签名的真实性。&lt;/p&gt;
&lt;p&gt;Note that we make no assumptions about a traitorous general&amp;rsquo;s signature. In particular, we allow his signature to be forged by another traitor, thereby permitting collusion among the traitors.&lt;br&gt;
Now that we have introduced signed messages, our previous argument that four generals are required to cope with one traitor no longer holds. In fact, a three-general solution does exist. We now give an algorithm that copes with m traitors for any number of generals. (The problem is vacuous if there are fewer than m + 2 generals.)&lt;/p&gt;
&lt;p&gt;请注意，我们对叛国将军的签名不做任何假设。特别是，我们允许他的签名被另一个叛徒伪造，从而允许叛徒之间的勾结。&lt;br&gt;
既然我们已经引入了签名信息，那么我们之前的论点，即需要四名将军来应对一个叛徒就不再成立了。事实上，一个三将军的解决方案确实存在。我们现在给出一个算法，可以应对任何数量的将军的m个叛徒。(如果少于m+2个将军，这个问题就是没有意义的）。&lt;/p&gt;
&lt;p&gt;In our algorithm, the commander sends a signed order to each of his lieutenants. Each lieutenant then adds his signature to that order and sends it to the other lieutenants, who add their signatures and send it to others, and so on. This means that a lieutenant must effectivelyreceive one signed message, make several copies of it, and sign and send those copies. It does not matter how these copies are obtained; a single message might be photocopied, or else each message might consist of a stack of identical messages which are signed and distributed as required.&lt;/p&gt;
&lt;p&gt;在我们的算法中，指挥官向他的每个中尉发送一个签名的命令。然后每个中尉在该命令上加上自己的签名，并将其发送给其他中尉，其他中尉再加上自己的签名，并将其发送给其他人，如此反复。这意味着，一个中尉必须有效地接收一份已签署的信息，将其复制几份，并签署和发送这些副本。如何获得这些副本并不重要；一份电文可能是复印的，否则每份电文可能由一叠相同的电文组成，这些电文按要求进行签署和分发。&lt;/p&gt;
&lt;p&gt;Our algorithm assumes a function choice which is applied to a set of orders to /obtain a single one. The only requirements we make for this function are&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;If the set V consists of the single element v, then choice(V) = v.&lt;/li&gt;
&lt;li&gt;choice(Q) = RETREAT, where ø is the empty set.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们的算法假定有一个函数选择，它被应用于一组命令，以获得一个单一的命令。我们对这个函数的唯一要求是&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果集合V由单一元素v组成，那么选择(V)=v。&lt;/li&gt;
&lt;li&gt;choice(Q) = RETREAT，其中是ø空集。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Note that one possible definition is to let choice(V) be the median element of V &amp;ndash; assuming that there is an ordering of the elements.&lt;br&gt;
In the following algorithm, we let x:i denote the value x signed by General i. Thus, v:j:i denotes the value v signed by j, and then that value v:j signed by i. We let General 0 be the commander. In this algorithm, each lieutenant i maintains a set Vi, containng the set of properly signed orders he has received so far. (If the commander is loyal, then this set should never contain more than a single element.) Do not confuse Vi, the set of orders he has received, with the set of messages that he has received. There may be many different messages with the same order.&lt;/p&gt;
&lt;p&gt;请注意，一个可能的定义是让choice(V)是V的中位数元素&amp;ndash;假设元素是有序的。&lt;br&gt;
在下面的算法中，我们让x:i表示由i将军签署的值x。因此，v:j:i表示由j签署的值v，然后是由i签署的那个值v:j。我们让0将军做指挥官。在这个算法中，每个中尉i维护一个集合Vi，包含他迄今为止收到的正确签署的命令集合。(如果指挥官是忠诚的，那么这个集合就不应该包含超过一个元素）。不要把Vi，即他所收到的命令集，与他所收到的信息集混淆起来。同一个命令可能有许多不同的信息。&lt;/p&gt;
&lt;p&gt;Algorithm SM (m).&lt;/p&gt;
&lt;p&gt;Initially Vi = 0. &lt;br&gt;
(1) The commander signs and sends his value to every lieutenant.&lt;br&gt;
(2) For each i:&lt;br&gt;
 (A) If Lieutenant i receives a message of the form v:0 from the commander and he has not yet received any order, then&lt;br&gt;
  (i) he lets V equal (v); &lt;br&gt;
  (ii) he sends the message v:0:i to everyother lieutenant. &lt;br&gt;
 (B) If Lieutenant i receives a message of the form v:0:j1:···:jk and v is not in the set Vi, then&lt;br&gt;
  (i) he adds v to Vi;&lt;br&gt;
  (ii) if k &amp;lt; m, then he sends the message v:0:j1:···:jk:i to every lieutenant other than j1&amp;hellip;..,jk.&lt;br&gt;
(3) For each i: When Lieutenant i will receive no more messages, he obeys the order choice(Vi).&lt;/p&gt;
&lt;p&gt;最初，Vi = 0。&lt;br&gt;
(1) 指挥官签署并将他的命令发送给每个中尉。&lt;br&gt;
(2) 对于每个i：&lt;br&gt;
 (A) 如果i中尉从指挥官那里收到形式为v:0的信息，并且他还没有收到任何命令，那么&lt;br&gt;
  (i) 他让V等于（v）。&lt;br&gt;
  (ii)他将信息v:0:i发送给其他所有的中尉。&lt;br&gt;
 (B) 如果i中尉收到一个形式为v:0:j1:&amp;ndash;:jk的信息，并且v不在集合V中，那么&lt;br&gt;
  (i) 他将v加入Vi。&lt;br&gt;
  (ii) 如果k &amp;lt; m，那么他将信息v:0:j1:&amp;mdash;:jk:i发送给除j1&amp;hellip;..,jk之外的每个中尉。&lt;br&gt;
(3) 对于每个i。当中尉i不会再收到信息时，他就会服从choice(Vi)的命令。&lt;/p&gt;
&lt;p&gt;Note that in step (2), Lieutenant i ignores any message containing an order v that is already in the set Vi.&lt;/p&gt;
&lt;p&gt;请注意，在步骤（2）中，中尉i会忽略任何包含已经在集合Vi中的命令v的消息。&lt;/p&gt;
&lt;p&gt;We have not specified how a lieutenant determines in step (3) that he will receive no more messages. By induction on k, one easily shows that for each sequence of lieutenants j1, ···, jk with k&amp;lt;=m, a lieutenant can receive at most one message of the form v:0:j1:···:jk in step (2). If we require that Lieutenant jk either send such a message or else send a message reporting that he will not send such a message, then it is easy to decide when all messages have been received. (By assumption A3, a lieutenant can determine if a traitorous lieutenant jk sends neither of those two messages.) Alternatively, time-out can be used to determine when no more messages will arrive. The use of time-out is discussed in Section 6.&lt;/p&gt;
&lt;p&gt;我们没有说明中尉如何在步骤(3)中确定他不会再收到信息。通过对k的归纳，我们很容易发现，对于每一个k&amp;lt;=m的中尉序列j1, &amp;mdash;, jk，一个中尉在步骤(2)中最多可以收到一条形式为v:0:j1:&amp;mdash;:jk的信息。如果我们要求中尉jk要么发送这样的信息，要么发送一个报告他不会发送这样的信息的信息，那么很容易决定何时所有信息都被收到了。(根据假设A3，中尉可以判断出叛徒中尉jk是否不发送这两条信息)。另外，也可以用超时来决定何时不再有信息到达。第6节将讨论超时的使用。&lt;/p&gt;
&lt;p&gt;Note that in step (2), Lieutenant i ignores any messages that do not have the proper form of a value followed by a string of signatures. If packets of identical messages are used to avoid having to copy messages, this means that he throws away any packet that does not consist of a sufficient number of identical, properly signed messages.(There should be(n-k-2)(n-k-3)···(n-m-2)copies of the message if it has been signed by k lieutenants.)&lt;/p&gt;
&lt;p&gt;请注意，在步骤(2)中，中尉i忽略了任何没有正确形式的信息，即一个值后面有一串签名的信息。如果使用相同的信息包来避免复制信息，这意味着他扔掉任何不包含足够数量的相同的、正确签名的信息包。（如果信息已经被k个中尉签名，应该有(n-k-2)(n-k-3)&amp;mdash;(n-m-2)份。）&lt;/p&gt;
&lt;p&gt;Figure 5 illustrates Algorithm SM(1) for the case of three generals when the commander is a traitor. The commander sends an &amp;ldquo;attack&amp;rdquo; order to one lieutenant and a &amp;ldquo;retreat&amp;rdquo; order to the other. Both lieutenants receive the two orders in step (2), so after step (2) V1 = V2 = {&amp;ldquo;attack&amp;rdquo;, &amp;ldquo;retreat&amp;rdquo;}, and they both obey the order choice( {&amp;ldquo;attack&amp;rdquo;, &amp;ldquo;retreat&amp;rdquo;} ). Observe that here, unlike the situation in Figure 2, the lieutenants know the commander is a traitor because his signature appears on two different orders, and A4 states that only he could have generated those signatures.&lt;br&gt;
In Algorithm SM(m), a lieutenant signs his name to acknowledge his receipt of an order. If he is the mth lieutenant to add his signature to the order, then that signature is not relayed to anyone else by its recipient, so it is superfluous. (More precisely, assumption A2 makes it unnecessary.) In particular, the lieutenants need not sign their messages in SM(1).&lt;/p&gt;
&lt;p&gt;图5说明了当指挥官是叛徒时三个将军的情况下的算法SM(1)。指挥官向一名中尉发出了 &amp;ldquo;攻击 &amp;ldquo;命令，向另一名中尉发出了 &amp;ldquo;撤退 &amp;ldquo;命令。两个中尉在步骤（2）中都收到了这两个命令，所以在步骤（2）之后，V1=V2={&amp;ldquo;进攻&amp;rdquo;，&amp;ldquo;撤退&amp;rdquo;}，他们都服从命令选择（{&amp;ldquo;进攻&amp;rdquo;，&amp;ldquo;撤退&amp;rdquo;}）。请注意，这里与图2的情况不同，中尉们知道指挥官是个叛徒，因为他的签名出现在两个不同的命令上，而且A4说只有他才能产生这些签名。&lt;br&gt;
在算法SM(m)中，一名中尉签署了他的名字，以确认他收到了一份命令。如果他是第m个在命令上签名的中尉，那么这个签名就不会被其接收者转达给其他人，所以它是多余的。(更确切地说，假设A2使其成为不必要的。)特别是，中尉们不需要在SM(1)中签署他们的信息。&lt;/p&gt;
&lt;p&gt;We now prove the correctness of our algorithm.&lt;/p&gt;
&lt;p&gt;证明算法&lt;/p&gt;
&lt;p&gt;THEOREM 2. For any m, Algorithm SM(m) solves the Byzantine Generals Problem if there are at most m traitors.&lt;/p&gt;
&lt;p&gt;定理2. 对于任何m，如果有最多m个叛徒，算法SM(m)可以解决拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;PROOF. We first prove IC2. If the commander is loyal, then he sends his signed order v:0 to every lieutenant in step (1). Every loyal lieutenant will therefore receive the order v in step (2)(A). Moreover, since no traitorous lieutenant can forge any other message of the form v&amp;rsquo;:0, a loyal lieutenant can receive no additional order in step (2)(B). Hence, for each loyal Lieutenant i, the set Vi obtained in step (2) consists of the single order v, which he will obey in step (3) by property 1 of the choice function. This proves IC2.&lt;br&gt;
Since IC1 follows from IC2 if the commander is loyal, to prove IC1 we need only consider the case in which the commander is a traitor. Two loyal lieutenants i and j obey the same order in step (3) if the sets of orders Vi and Vj that they receive in step (2) are the same. Therefore, to prove IC1 it suffices to prove that, if i puts an order v into Vi in step (2), thenj must put the same order v into V1in step (2). To do this, we must show that j receives a properly signed message containing that order. If i receives the order v in step (2)(A), then he sends it to
j in step (2)(A)(ii); so j receives it (by A1). If i adds the order to Vi in step (2)(B), then he must receive a first message of the form v:0 :j1:···:jk. If j is one of the jr, then by A4 he must already have received the order v. If not, we consider two cases:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;k &amp;lt; m. In this case, i sends the message v:0:j1: &amp;hellip; :jk:i to j; soj must receive the order v.&lt;/li&gt;
&lt;li&gt;k = m. Since the commander is a traitor, at most m - 1 of the lieutenants are traitors. Hence, at least one of the lieutenants j1, &amp;hellip;. , jm is loyal. This loyal lieutenant must have sent j the value v when he first received it, so j must therefore receive that value.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;证明。我们首先证明IC2。如果指挥官是忠诚的，那么他在步骤(1)中向每个中尉发送了他签署的命令v:0。因此，每个忠诚的中尉都会在步骤（2）（A）中收到命令v。此外，由于没有一个叛徒中尉可以伪造任何其他形式的v&amp;rsquo;:0的信息，忠诚的中尉在步骤(2)(B)中无法收到任何额外的命令。因此，对于每个忠诚的中尉i来说，在步骤(2)中得到的集合Vi包括单一的命令v，根据选择函数的属性1，他将在步骤(3)中服从这个命令。这就证明了IC2。&lt;br&gt;
由于如果指挥官是忠诚的，则IC1由IC2得出，为了证明IC1，我们只需要考虑指挥官是叛徒的情况。如果两个忠诚的中尉i和j在步骤(3)中接受的命令集Vi和Vj是相同的，那么他们在步骤(2)中就会服从同一个命令。因此，要证明IC1，只需证明，如果i在步骤(2)中将一个命令v放入Vi中，那么j在步骤(2)中必须将同样的命令v放入V1中。要做到这一点，我们必须证明j收到一个包含该命令的正确签名信息。如果i在步骤(2)(A)中收到了命令v，那么他就把它发送给了j, 在步骤(2)(A)(ii)中；所以j收到了它（通过A1）。如果i在步骤(2)(B)中将订单添加到Vi中，那么他必须收到形式为v:0 :j1:&amp;mdash;:jk的第一个信息。如果j是jr之一，那么根据A4，他一定已经收到了订单v。 如果不是，我们考虑两种情况:&lt;/p&gt;
&lt;p&gt;1.在这种情况下，i向j发送了v:0:j1:&amp;hellip;:jk:i的信息；所以j必须接受命令v。&lt;/p&gt;
&lt;p&gt;2.k=m。由于指挥官是叛徒，所以最多只有m-1名中尉是叛徒。因此，至少有一个中尉j1, &amp;hellip;. , jm是忠诚的。这个忠诚的中尉在第一次收到价值v的时候，一定给j发送了这个命令，因此j一定会收到这个命令。&lt;/p&gt;
&lt;h2 id="5-missing-communication-paths"&gt;5. MISSING COMMUNICATION PATHS
&lt;/h2&gt;&lt;p&gt;Thus far, we have assumed that a general can send messages directly to every other general. We now remove this assumption. Instead, we suppose that physical barriers place some restrictions on who can send messages to whom. We consider the generals to form the nodes of a simple, finite undirected graph G, where an arc between two nodes indicates that those two generals can send messages directly to one another. We now extend Algorithms OM(m) and SM(m), which assumed G to be completely connected, to more general graphs.&lt;br&gt;
To extend our oral message algorithm OM(m), we need the following definition, where two generals are said to be neighbors if they are joined by an arc.&lt;/p&gt;
&lt;p&gt;到目前为止，我们假设一个将军可以直接向其他每个将军发送信息。现在我们取消这一假设。相反，我们假设物理屏障对谁能向谁发送信息有一些限制。我们认为将军们构成了一个简单的、有限的无向图G的节点，其中两个节点之间的弧表示这两个将军可以直接向对方发送消息。现在我们将假设G是完全连接的算法OM(m)和SM(m)扩展到更一般的图。&lt;br&gt;
为了扩展我们的口头信息算法OM(m)，我们需要以下定义，如果两个将军被一条弧连接，就说它们是邻居。&lt;/p&gt;
&lt;p&gt;Definition 1.&lt;/p&gt;
&lt;p&gt; (a) A set of nodes (il, &amp;hellip;, ip} is said to be a regular set of neighbors of a node if&lt;br&gt;
  (i) each ij is a neighbor of i, and
  (ii) for any general k different from i, there exist paths yj,kfrom ijto k not passing through i such that any two different paths Yi,khave no node in common other than k.&lt;/p&gt;
&lt;p&gt;定义1.&lt;br&gt;
 (a) 一组节点（il，&amp;hellip;，ip}被称为是一个节点的常规邻居集，如果&lt;br&gt;
  (i) 每个ij都是i的邻居，并且&lt;br&gt;
  (ii) 对于任何不同于i的k，存在从ij到k的不经过i的路径yj,k，使得任何两个不同的路径Yi,k除了k之外没有共同的节点。&lt;/p&gt;
&lt;p&gt; (b) The graph G is said to be p-regular if every node has a regular set of neighbors consisting of p distinct nodes.&lt;/p&gt;
&lt;p&gt; (b) 如果每个节点都有一个由p个不同节点组成的规则的邻居集，则称图G为p-规则。&lt;/p&gt;
&lt;p&gt;Figure 6 shows an example of a simple 3-regular graph. Figure 7 shows an example of a graph that is not 3-regular because the central node has no regular set of neighbors containing three nodes.&lt;/p&gt;
&lt;p&gt;图6是一个简单的3-规则图的例子。图7显示了一个非3规则图的例子，因为中心节点没有包含三个节点的规则邻居集。&lt;/p&gt;
&lt;p&gt;We extend OM(m) to an algorithm that solves the Byzantine Generals Problem in the presence of m traitors if the graph G of generals is 3m-regular. (Note that a 3m-regular graph must contain at least 3m + 1 nodes.} For all positive integers m and p, we define the algorithm OM(m, p) as follows when the graph G of generals is p-regular. (OM(m,p) is not defined if G is not p-regular.) The definition uses induction on m.&lt;/p&gt;
&lt;p&gt;我们将OM(m)扩展为一种算法，如果图G是3m规则的，那么在有m个叛徒的情况下，可以解决拜占庭将军问题。(请注意，一个3m规则的图必须至少包含3m+1个节点)。对于所有正整数m和p，当将军图G是p-regular时，我们定义算法OM(m, p)如下。(如果G不是p-regular，OM(m,p)就没有定义) 。该定义使用了对m的归纳法。&lt;/p&gt;
&lt;p&gt;Algorithm OM(m,p).&lt;/p&gt;
&lt;p&gt; (0) Choose a regular set N of neighbors of the commander consisting ofp lieutenants.&lt;br&gt;
 (1) The commander sends his value to every lieutenant in N.&lt;br&gt;
 (2) For each i in N, let vi be the value Lieutenant i receives from the commander, or else RETREAT if he receives no value. Lieutenant i sends vi to every other lieutenant k as follows:&lt;br&gt;
  (A) If m = 1, then by sending the value along the path yi,k whose existence is guaranteed by part (a)(ii) of Definition 1.&lt;br&gt;
  (B) If rn &amp;gt; 1, then by acting as the commander in the algorithm OM(m - 1, p - 1), with the graph of generals obtained by removing the original commander from G.&lt;br&gt;
 (3) For each k, and each i in N with i ~ k, let vi be the value Lieutenant k received from Lieutenant i in step (2), or RETREAT if he received no value. Lieutenant k uses the value majority(vi&amp;hellip;&amp;hellip; vi,), where N = {il&amp;hellip;.. ip}.&lt;/p&gt;
&lt;p&gt; (0) 选择一个由p个中尉组成的指挥官的常规邻居集N。&lt;br&gt;
 (1) 指挥官向N中的每个中尉发送他的命令。&lt;br&gt;
 (2) 对于N中的每一个i，让vi成为i中尉从指挥官那里收到的命令，如果他没有收到任何价值，则RETREAT。中尉i将vi发送给其他每个中尉k，如下所示。&lt;br&gt;
  (A) 如果m=1，那么通过沿路径yi,k发送命令，其存在由定义1的(a)(ii)部分保证。&lt;br&gt;
  (B) 如果m&amp;gt;1，那么通过在算法OM(m - 1, p - 1)中充当指挥官，通过从G中删除原指挥官得到将军图。&lt;br&gt;
 (3) 对于每个k，以及N中的每个i，i ~ k，让vi为k中尉在步骤(2)中从i中尉那里收到的命令，如果他没有收到命令，则RETREAT。中尉k使用价值 majority(vi&amp;hellip;&amp;hellip;vi)其中N = {i1&amp;hellip;.. ip}。&lt;/p&gt;
&lt;p&gt;Note that removing a single node from a p-regular graph leaves a (p - 1) regular graph. Hence, one can apply the algorithm OM(m - 1, p - 1) in step (2)(B).&lt;/p&gt;
&lt;p&gt;请注意，从一个p-regular图中移除一个节点，会留下一个（p - 1）regular图。因此，我们可以在步骤(2)(B)中应用算法OM(m - 1, p - 1)。&lt;/p&gt;
&lt;p&gt;We now prove that OM(m, 3m) solves the Byzantine Generals Problem if there are at most m traitors. The proof is similar to the proof for the algorithm OM(m) and will just be sketched. It begins with the following extension of Lemma 1.&lt;/p&gt;
&lt;p&gt;我们现在证明OM(m, 3m)解决了拜占庭将军问题，如果有最多m个叛徒的话。该证明与OM(m)算法的证明类似，将只是略加说明。它从以下对结论1的扩展开始。&lt;/p&gt;
&lt;p&gt;LEMMA 2. For any m &amp;gt; 0 and any p &amp;gt; 2k + m, Algorithm OM (m, p) satisfies IC2 if there are at most k traitors.&lt;/p&gt;
&lt;p&gt;LEMMA 2. 对于任何m&amp;gt;0和任何p&amp;gt;2k+m，如果最多有k个叛徒，那么算法OM（m，p）满足IC2。&lt;/p&gt;
&lt;p&gt;PROOF. For m=1, observe that a lieutenant obtains the value majority(v1, &amp;hellip;, vp), where each vi is a value sent to him by the commander along a path disjoint from the path used to send the other values to him. Since there are at most k traitors and p = 2k + 1, more than half of those paths are composed entirely of loyal lieutenants. Hence, if the commander is loyal, then a majority of the values vi will equal the value he sent, which implies that IC2 is satisfied.&lt;br&gt;
Now assume the lemma for m - 1, m &amp;gt; 1. If the commander is loyal, then each of the p lieutenants in N gets the correct value. Since p &amp;gt; 2k, a majority of them are loyal, and by the induction hypothesis each of them sends the correct value to every loyal lieutenant. Hence, each loyal lieutenant gets a majority of correct values, thereby obtaining the correct value in step (3).&lt;/p&gt;
&lt;p&gt;证明。对于m=1，观察一下，一个中尉获得的值是 majority(v1, &amp;hellip;, vp)，其中每个vi是由指挥官沿着与用来发送其他值的路径不相交的路径发送给他的一个值。由于最多只有k个叛徒，p=2k+1，这些路径中有一半以上完全由忠诚的中尉组成。因此，如果指挥官是忠诚的，那么大多数的值将等于他发送的值，这意味着IC2被满足。&lt;br&gt;
现在假设m-1，m&amp;gt;1的定理。如果指挥官是忠诚的，那么N中的p个中尉都会得到正确的价值。由于p&amp;gt;2k，他们中的大多数人都是忠诚的，根据归纳假设，他们中的每一个人都向每个忠诚的中尉发送了正确的价值。因此，每个忠诚的中尉都得到了大多数的正确值，从而得到了步骤（3）中的正确值。&lt;/p&gt;
&lt;p&gt;The correctness of Algorithm OM(m, 3m) is an immediate consequence of the following result.&lt;/p&gt;
&lt;p&gt;算法OM(m, 3m)的正确性是以下结果的直接结果。&lt;/p&gt;
&lt;p&gt;THEOREM 3. For any m &amp;gt; 0 and any p &amp;gt; 3m, Algorithm OM(m, p) solves the Byzantine Generals Problem if there are at most m traitors.&lt;/p&gt;
&lt;p&gt;PROOF. By Lemma 2, letting k = m, we see that OM(m, p) satisfies IC2. If the commander is loyal, then IC1 follows from IC2, so we need only prove IC1 under the assumption that the commander is a traitor. To do this, we prove that every loyal lieutenant gets the same set of values vi in step (3). If m = 1, then this follows because all the lieutenants, including those in N, are loyal and the paths yi,k do not pass through the commander. For m &amp;gt; 1, a simple induction argument can be applied, since p-1&amp;gt;=3m implies that p-1&amp;gt;=3(m - 1).&lt;/p&gt;
&lt;p&gt;定理3. 对于任何m&amp;gt;0和任何p&amp;gt;3m，如果有最多m个叛徒，算法OM(m, p)就能解决拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;证明。根据定理2，让k=m，我们看到OM(m, p)满足IC2。如果指挥官是忠诚的，那么IC1由IC2得出，所以我们只需要在指挥官是叛徒的假设下证明IC1。要做到这一点，我们要证明每个忠诚的中尉在步骤（3）中得到相同的价值集。如果m=1，那么这就意味着，所有的中尉，包括N中的中尉，都是忠诚的，而且路径yi,k不经过司令官。对于m&amp;gt;1，可以应用一个简单的归纳论证，因为p-1&amp;gt;=3m意味着p-1&amp;gt;=3（m - 1）。&lt;/p&gt;
&lt;p&gt;Our extension of Algorithm OM(m) requires that the graph G be 3m-regular, which is a rather strong connectivity hypothesis. 3 In fact, if there are only 3m + 1 generals (the minimum number required), then 3m-regularity means complete connectivity, and Algorithm OM(m, 3m) reduces to Algorithm OM(m). In contrast, Algorithm SM(m) is easily extended to allow the weakest possible connectivity hypothesis. Let us first consider how much connectivity is needed for the Byzantine Generals Problem to be solvable. IC2 requires that a loyal lieutenant obey a loyal commander. This is clearly impossible if the commander cannot communicate with the lieutenant. In particular, if every message from the commander to the lieutenant must be relayed by traitors, then there is no way to guarantee that the lieutenant gets the commander&amp;rsquo;s order. Similarly, IC1 cannot be guaranteed if there are two lieutenants who can only communicate with one another via traitorous intermediaries.&lt;/p&gt;
&lt;p&gt;The weakest connectivity hypothesis for which the Byzantine Generals Problem is solvable is that the subgraph formed by the loyal generals be connected. We show that under this hypothesis, the algorithm SM(n - 2) is a solution, where n is the number of generals&amp;ndash;regardless of the number of traitors. Of course, we must modify the algorithm so that generals only send messages to where they can be sent. More precisely, in step (1), the commander sends his signed order only to his neighboring lieutenants; and in step (2)(B), Lieutenant i only sends the message to every neighboring lieutenant not among the jr.&lt;/p&gt;
&lt;p&gt;我们对算法OM(m)的扩展要求图G是3m-规则的，这是一个相当强的连接性假设。3 事实上，如果只有3m+1个将军（所需的最小数量），那么3m-规则性就意味着完全连通性，而算法OM(m, 3m)就简化为算法OM(m)。相比之下，算法SM(m)很容易扩展到允许最弱的连接性假设。让我们首先考虑拜占庭将军问题需要多少连通性才能被解决。IC2要求一个忠诚的中尉服从一个忠诚的指挥官。如果指挥官不能与中尉沟通，这显然是不可能的。特别是，如果从指挥官到中尉的每条信息都必须由叛徒转达，那么就没有办法保证中尉得到指挥官的命令。同样，如果有两个中尉只能通过叛徒的中间人相互沟通，那么IC1也无法保证。&lt;/p&gt;
&lt;p&gt;拜占庭将军问题可解的最弱连接性假设是，由忠诚的将军们形成的子图是连接的。我们表明，在这个假设下，算法SM(n - 2)是一个解决方案，其中n是将军的数量&amp;ndash;无论叛徒的数量如何。当然，我们必须修改算法，使将军们只把信息发送到可以发送的地方。更确切地说，在步骤(1)中，指挥官只将他签署的命令发送给他邻近的中尉；而在步骤(2)(B)中，中尉i只将信息发送给每一个不在jr的邻近中尉。&lt;/p&gt;
&lt;p&gt;We prove the following more general result, where the diameter of a graph is the smallest number d such that any two nodes are connected by a path containing at most d arcs.&lt;/p&gt;
&lt;p&gt;我们证明以下更一般的结果，图的直径是最小的数字d，即任何两个节点都由最多包含d个弧的路径连接。&lt;/p&gt;
&lt;p&gt;THEOREM 4. For any m and d, if there are at most m traitors and the subgraph of loyal generals has diameter d, then Algorithm SM(m + d - 1) (with the above modification) solves the Byzantine Generals Problem.&lt;/p&gt;
&lt;p&gt;定理4. 对于任何m和d，如果最多存在m个叛徒，并且忠诚将军的子图的直径为d，那么算法SM(m + d - 1)（经过上述修改）可以解决拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;PROOF. The proof is quite similar to that of Theorem 2 and is just sketched here. To prove IC2, observe that by hypothesis there is a path from the loyal commander to a lieutenant i going through d - 1 or fewer loyal lieutenants. Those lieutenants will correctly relay the order until it reaches i. As before, assumption A4 prevents a traitor from forging a different order.&lt;br&gt;
To prove IC1, we assume the commander is a traitor and must show that any order received by a loyal lieutenant i is also received by a loyal lieutenant j. Suppose i receives an order v:0:j1:···:jk not signed by j. If k &amp;lt; m, then i will send it to every neighbor who has not already received that order, and it will be relayed to j within d - 1 more steps. If k &amp;gt; m, then one of the first m signers must be loyal and must have sent it to all of his neighbors, whereupon it will be relayed by loyal generals and will reach j within d - 1 steps.&lt;/p&gt;
&lt;p&gt;证明。该证明与定理2非常相似，在此仅作简要说明。为了证明IC2，请注意，根据假设，有一条从忠诚的指挥官到中尉i的路径要经过d-1或更少的忠诚中尉。这些中尉将正确地转达命令，直到它到达i。如前所述，假设A4防止叛徒伪造不同的命令。&lt;br&gt;
为了证明IC1，我们假设指挥官是个叛徒，并且必须证明忠心的中尉i收到的任何命令也会被忠心的中尉j收到。假设i收到一个没有j签名的命令v:0:j1:&amp;ndash;:jk。如果k&amp;gt;m，那么前m个签名者中的一个一定是忠诚的，而且一定是把它发送给了他的所有邻居，这时它将被忠诚的将军们转发，并在d-1步内到达j。&lt;/p&gt;
&lt;p&gt;COROLLARY. If the graph of loyal generals is connected, then SM(n - 2) (as modified above) solves the Byzantine Generals Problem for n generals.&lt;/p&gt;
&lt;p&gt;推论。如果忠诚将军的图是连接的，那么SM(n - 2)(如上文所修改)解决了n个将军的拜占庭将军问题。&lt;/p&gt;
&lt;p&gt;PROOF. Let d be the diameter of the graph of loyal generals. Since the diameter of a connected graph is less than the number of nodes, there must be more than d loyal generals and fewer than n - d traitors. The result follows from the theorem by letting m=n - d - 1.&lt;/p&gt;
&lt;p&gt;证明。设d为忠诚将军图的直径。由于连通图的直径小于节点数，所以忠诚的将军一定多于d，而叛徒一定少于n-d。由定理可知，结果是让m=n - d - 1。&lt;/p&gt;
&lt;p&gt;Theorem 4 assumes that the subgraph of loyal generals is connected. Its proof is easily extended to show that even if this is not the case, if there are at most m traitors, then the algorithm SM(m + d - 1) has the following two properties:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Any two loyal generals connected by a path of length at most d passing through only loyal generals will obey the same order.&lt;/li&gt;
&lt;li&gt;If the commander is loyal, then any loyal lieutenant connected to him by a path of length at most m + d passing only through loyal generals will obey his order.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;定理4 假设忠诚将军的子图是连接的。它的证明很容易扩展到表明，即使不是这样，如果有最多m个叛徒，那么算法SM(m + d - 1)有以下两个特性。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;任何两个忠诚的将军被一条最多通过忠诚将军的长度为d的路径所连接，都将服从相同的命令。&lt;/li&gt;
&lt;li&gt;如果指挥官是忠诚的，那么任何与他相连的忠诚的中尉，通过一条长度最多为m+d的路径，只经过忠诚的将军，都会服从他的命令。&lt;/li&gt;
&lt;/ol&gt;</description></item><item><title>Why events are a bad idea</title><link>https://MyLoveES.github.io/p/why-events-are-a-bad-idea/</link><pubDate>Wed, 23 Mar 2022 18:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/why-events-are-a-bad-idea/</guid><description>&lt;h1 id="why-events-are-a-bad-idea"&gt;Why Events Are A Bad Idea
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;论点：线程可以实现事件的所有优点，包括支持高并发性、低开销和简单的并发模型。此外，线程允许更简单和更自然的编程风格。&lt;/li&gt;
&lt;/ul&gt;
&lt;details&gt;
&lt;summary&gt;原文&lt;/summary&gt;
&lt;blockquote&gt;
&lt;p&gt;Specifically, we believe that threads can achieve all of the strengths of events, including support for high concurrency, low overhead, and a simple concurrency model. Moreover, we argue that threads allow a simpler and more natural programming style.&lt;/p&gt;&lt;/blockquote&gt;
&lt;/details&gt;
&lt;p&gt;过去的一段时间（论文发表前），人们认为Event-oriented是高并发程序中实现高性能的最佳方法。
主要原因有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;由于协作多任务处理，同步的成本很低;&lt;/li&gt;
&lt;li&gt;管理状态的开销更低(没有栈);&lt;/li&gt;
&lt;li&gt;基于应用级的信息，更好的调度和局部性;&lt;/li&gt;
&lt;li&gt;更灵活的控制流(不仅仅是调用/返回);&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是作者认为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;线程为高并发服务器提供了一个更自然的抽象;&lt;/li&gt;
&lt;li&gt;对编译器和线程运行时系统的小改进可以消除使用事件的历史原因;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;线程更易于接受基于编译器的增强;&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;details&gt;
&lt;summary&gt;原文&lt;/summary&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-go" data-lang="go"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="err"&gt;•&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Inexpensive&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;synchronization&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;due&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;cooperative&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;multitasking&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="err"&gt;•&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Lower&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;overhead&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;managing&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;state&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;no&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;stacks&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="err"&gt;•&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Better&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;scheduling&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;locality&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;based&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;on&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="nx"&gt;application&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;level&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;information&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="err"&gt;•&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;More&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;flexible&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;control&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;flow&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;not&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;just&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;call&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="w"&gt;&lt;/span&gt;&lt;span class="nx"&gt;We&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;believe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;that&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;threads&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;provide&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;more&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;natural&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;abstraction&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;high&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;concurrency&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;servers&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nf"&gt;that&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;small&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;improvements&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;compilers&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;and&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;runtime&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;systems&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;can&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;eliminate&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;historical&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;reasons&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;use&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;events&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;Additionally&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;threads&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;are&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;more&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;amenable&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;to&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;compiler&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="nx"&gt;based&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;enhancements&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;we&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;believe&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;the&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;right&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;paradigm&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;highly&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;concurrent&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;applications&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;is&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;a&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;thread&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="kn"&gt;package&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;with&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;better&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;compiler&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="nx"&gt;support&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="w"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h2 id="duality-revisited"&gt;Duality Revisited
&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;event handlers&lt;/td&gt;
&lt;td&gt;monitors&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;events accepted by a handler&lt;/td&gt;
&lt;td&gt;functions exported by a module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendMessage / AwaitReply&lt;/td&gt;
&lt;td&gt;procedure call, or fork/join&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendReply&lt;/td&gt;
&lt;td&gt;return from procedure&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;waiting for messages&lt;/td&gt;
&lt;td&gt;waiting on condition variables&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;ul&gt;
&lt;li&gt;First, Lauer and Needham ignore the cooperative scheduling used by events for synchronization.&lt;/li&gt;
&lt;li&gt;Second, most event systems use shared memory and global data structures, which are described as atypical for Lauer and Needham’s message- passing systems.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="problems-with-threads"&gt;“Problems” with Threads
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://MyLoveES.github.io/ConcurrentTasks.png"
loading="lazy"
&gt;&lt;/p&gt;
&lt;h3 id="performance"&gt;Performance
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Criticism: 许多尝试使用线程实现的高并发模型并不是很棒&lt;br&gt;
开销的主要来源是，存在和线程数相关的O(n)的操作的存在；并且上下文切换开销大（由于需要保存寄存器和其他状态，以及kernel crossings）。但这些是线程工具包实现的问题，而非线程自身的问题。 // TODO: 什么是上下文切换，并且为什么开销大&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="control-flow"&gt;Control flow
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Criticism: 线程是有限制性的控制流。它鼓励程序员对控制流进行过于线性的思考，可能会排除使用更有效的控制流模式。&lt;br&gt;
复杂的控制流模式在实践中是很少见的，并且在不同类型的系统中都需要得到处理。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="synchronization"&gt;Synchronization
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Criticism: 线程同步机制很重 // TODO: 什么是线程同步？我的理解应该是说，加锁保证同步&lt;br&gt;
事件系统认为合作多任务模式&amp;quot;免费&amp;quot;地为它们提供了同步机制，运行时系统无需处理互斥、等待队列等等。但是仅仅是在单处理器上实现，而现在大多是多处理器。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="state-management"&gt;State Management
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Criticism: 线程堆栈不是管理实时状态的一种有效方式。线程系统通常面临着堆栈溢出的风险和在大堆栈上浪费虚拟地址空间之间的权衡&lt;br&gt;
作者手动解决&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="scheduling"&gt;Scheduling
&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;Criticism: 线程提供的虚拟处理器模型使运行时系统过于泛化，使其无法做出最佳调度决策 // TODO: 啥意思？&lt;br&gt;
事件系统能够在应用层面上调度事件的交付。因此，应用程序可以执行最短的剩余完成时间调度，有利于某些请求流，或执行其他优化。也有一些证据表明，通过连续运行几个相同类型的事件，事件允许更好的代码定位[9]。然而，Lauer-Needham二元性表明，我们可以将同样的调度技巧应用于合作调度的线程。&lt;/p&gt;&lt;/blockquote&gt;
&lt;h3 id="conclusion"&gt;Conclusion
&lt;/h3&gt;&lt;p&gt;上述论点表明，在高并发性方面，线程的性能至少与事件一样好，而且事件在质量上没有实质性的优势。&lt;br&gt;
可扩展的用户级线程的缺失为事件风格提供了最大的推动力，但我们已经表明，这一缺陷是现有实现的一个伪命题，而不是线程抽象的一个基本属性。&lt;br&gt;
（作者认为，上面列举的问题都不是线程本身的锅！都是实现方式造成的！EventDriven和Threads能达到同样的效果！）&lt;/p&gt;
&lt;h2 id="the-case-for-threads"&gt;The Case for Threads
&lt;/h2&gt;&lt;p&gt;对于高并发服务器，线程是更合理的抽象。原因有二：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;并发请求之间，很大程度上是彼此独立的。&lt;/li&gt;
&lt;li&gt;处理请求的代码是顺序的。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id="control-flow-1"&gt;Control flow
&lt;/h3&gt;&lt;p&gt;基于事件的系统，往往会混淆应用程序的事件流，因为不同环节之间实际是通过“事件”连接的。Coder需要记住并且匹配event和环节，并且不便于调试。&lt;br&gt;
而线程模型表达控制流的方式更自然（线性处理）了，并且线程堆栈封装了足够的信息来进行调试。&lt;/p&gt;
&lt;h3 id="exception-handling-and-state-lifetime"&gt;Exception Handling and State Lifetime
&lt;/h3&gt;&lt;p&gt;在线程系统中，在异常和正常终止后清理任务状态更简单，因为线程堆栈自然会跟踪该任务的活动状态。&lt;br&gt;
在事件系统中，任务状态通常是堆分配的。在正确的时间释放这个状态是非常困难的，因为应用程序控制流中的分支(特别是在错误条件下)可能会导致错过释放步骤。 // ?&lt;/p&gt;
&lt;h2 id="compiler-support-for-threads"&gt;Compiler Support for Threads
&lt;/h2&gt;&lt;p&gt;编译器和系统紧密结合, 实现更好的安全性和性能!&lt;/p&gt;
&lt;h3 id="动态堆栈增长"&gt;动态堆栈增长
&lt;/h3&gt;&lt;p&gt;运行时调整堆栈大小，避免固定大小堆带来的溢出风险和内存浪费。通过编译器分析来得到所需堆栈空间的上限及增长点。&lt;/p&gt;
&lt;h3 id="实时状态管理"&gt;实时状态管理
&lt;/h3&gt;&lt;p&gt;清除不必要的状态(state)，检测阻塞调用中持有大量实例的情况等等。&lt;/p&gt;
&lt;h3 id="同步"&gt;同步
&lt;/h3&gt;&lt;p&gt;编译器警告数据竞争处来减少错误的发生。&lt;/p&gt;
&lt;h2 id="conclusion-1"&gt;Conclusion
&lt;/h2&gt;&lt;p&gt;线程模型能够达到和事件驱动几乎一样的性能效果，并且模型更简单，更易于编译器分析，因此 Threads 是一个更好的编程模型。&lt;/p&gt;
&lt;h1 id="ref"&gt;Ref
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ref: &lt;a class="link" href="http://capriccio.cs.berkeley.edu/pubs/threads-hotos-2003.pdf" target="_blank" rel="noopener"
&gt;Why events are a bad idea&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description></item><item><title>Why threads are a bad idea (for most purposes)</title><link>https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/</link><pubDate>Tue, 22 Mar 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/</guid><description>&lt;p&gt;// 发现本文很多概念在现在已经不适用了，不做参考&lt;/p&gt;
&lt;h1 id="threads"&gt;Threads
&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;诞生于操作系统的发展&lt;/li&gt;
&lt;li&gt;演变为用户级别的工具&lt;/li&gt;
&lt;li&gt;作为各种问题的解决方案&lt;/li&gt;
&lt;li&gt;每个程序员都应该是线程程序员？&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id="什么是线程"&gt;什么是线程
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/Threads.png"
width="1468"
height="536"
srcset="https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/Threads_hu_7f82b31f2c00a7fc.png 480w, https://MyLoveES.github.io/p/why-threads-are-a-bad-idea-for-most-purposes/Threads_hu_1da6e77f16e20fe3.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="273"
data-flex-basis="657px"
&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;用于管理并发的通用解决方案&lt;/li&gt;
&lt;li&gt;执行流彼此独立&lt;/li&gt;
&lt;li&gt;共享状态&lt;/li&gt;
&lt;li&gt;抢占式调度&lt;/li&gt;
&lt;li&gt;同步（例如锁、条件）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="问题"&gt;问题
&lt;/h2&gt;&lt;p&gt;线程编程很难用&lt;/p&gt;
&lt;h2 id="为啥这么难用"&gt;为啥这么难用
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;必须对共享资源加锁来控制访问&lt;/li&gt;
&lt;li&gt;由锁产生的死锁问题&lt;/li&gt;
&lt;li&gt;难以 debug. 依赖数据和时间&lt;/li&gt;
&lt;li&gt;难以抽象 modules&lt;/li&gt;
&lt;li&gt;回调在加锁的场景下很难用&lt;/li&gt;
&lt;li&gt;很难取得好的性能：
&lt;ol&gt;
&lt;li&gt;简单的锁(例如监视器)产生低并发性&lt;/li&gt;
&lt;li&gt;细粒度锁增加了复杂度，降低了性能&lt;/li&gt;
&lt;li&gt;操作系统限制性能(调度、上下文切换)&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;对线程支持的不好
&lt;ol&gt;
&lt;li&gt;线程代码难以移植&lt;/li&gt;
&lt;li&gt;标准库非线程安全的&lt;/li&gt;
&lt;li&gt;内核调用，窗口系统不是多线程&lt;/li&gt;
&lt;li&gt;调试工具匮乏&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;通常不需要并发&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="替代品"&gt;替代品
&lt;/h2&gt;&lt;p&gt;Events&lt;/p&gt;
&lt;h2 id="主张"&gt;主张
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;大多数情况下，事件更好&lt;/li&gt;
&lt;li&gt;只有在真正需要CPU并发的时候，线程才需要&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="event-driven-programming"&gt;Event-Driven Programming
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1个执行流:无CPU并发。&lt;/li&gt;
&lt;li&gt;注册事件回调&lt;/li&gt;
&lt;li&gt;事件循环等待事件，调用处理程序&lt;/li&gt;
&lt;li&gt;不抢占事件处理程序&lt;/li&gt;
&lt;li&gt;handler通常生命周期很短&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="难用的地方"&gt;难用的地方
&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;长时间运行的环节使应用程序无响应
&lt;ol&gt;
&lt;li&gt;fork 子进程，用事件在完成时唤醒&lt;/li&gt;
&lt;li&gt;拆分handlers&lt;/li&gt;
&lt;li&gt;在处理程序中定期调用事件循环（重入性增加了复杂性）。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;不能跨事件维持本地状态（处理程序必须return）&lt;/li&gt;
&lt;li&gt;没有CPU并发（不适合科学应用）&lt;/li&gt;
&lt;li&gt;事件驱动的I/O并不总是得到很好的支持（例如差劲的写缓冲）&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="events-vs-threads"&gt;Events vs. Threads
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;事件尽可能避免并发，线程相反：
&lt;ol&gt;
&lt;li&gt;事件易于上手：无并发、无抢占、无同步、无死锁。&lt;/li&gt;
&lt;li&gt;仅在不寻常的情况下使用复杂的技术。&lt;/li&gt;
&lt;li&gt;使用线程，即使是最简单的应用程序也面临着很大的复杂性。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;使用事件更容易调试
&lt;ol&gt;
&lt;li&gt;时序依赖只与事件相关，与事件内部调度无关&lt;/li&gt;
&lt;li&gt;更容易追踪的问题：按钮响应缓慢 vs 损坏的内存&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;单CPU上事件驱动更快
&lt;ol&gt;
&lt;li&gt;没有锁的开销&lt;/li&gt;
&lt;li&gt;没有上下文切换&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;事件的可以执行更强&lt;/li&gt;
&lt;li&gt;线程提供真正的并发
&lt;ol&gt;
&lt;li&gt;可以使用长时间运行的有状态处理程序而不会冻结&lt;/li&gt;
&lt;li&gt;可扩展的多cpu性能&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="应该用线程吗no"&gt;应该用线程吗：NO！
&lt;/h1&gt;&lt;p&gt;尽可能避免线程:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于gui、分布式系统、低端服务器，应该使用事件，而不是线程&lt;/li&gt;
&lt;li&gt;只使用真正需要CPU并发的线程&lt;/li&gt;
&lt;li&gt;在需要线程的地方，在线程应用程序内核中隔离使用:保持大多数代码是单线程的&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="conclusions"&gt;Conclusions
&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;并发从根本上来说很难;尽可能的避免。&lt;/li&gt;
&lt;li&gt;线程比事件更强大，但很少需要这种能力&lt;/li&gt;
&lt;li&gt;线程比事件更难编程;仅供专家&lt;/li&gt;
&lt;li&gt;使用事件作为主要的开发工具(gui和分布式系统)&lt;/li&gt;
&lt;li&gt;只对性能关键的内核使用线程&lt;/li&gt;
&lt;/ul&gt;
&lt;h1 id="ref"&gt;Ref
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ref: &lt;a class="link" href="https://www.cc.gatech.edu/classes/AY2010/cs4210_fall/papers/ousterhout-threads.pdf" target="_blank" rel="noopener"
&gt;Why Threads Are a Bad Idea&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description></item><item><title>事件驱动 or 面向过程</title><link>https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</link><pubDate>Mon, 21 Mar 2022 00:00:00 +0000</pubDate><guid>https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</guid><description>&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/funny_compare.png"
width="1400"
height="770"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/funny_compare_hu_4cdf0406c8c108c8.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/funny_compare_hu_1d43c3679bcdf975.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="181"
data-flex-basis="436px"
&gt;&lt;/p&gt;
&lt;h1 id="背景"&gt;背景
&lt;/h1&gt;&lt;p&gt;业务中碰到一个场景，服务需要处理一个Job，分为几个阶段：Pre Do After。实现业务逻辑有两种比较常见的模式:&lt;/p&gt;
&lt;p&gt;线程池
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Procedure.png"
width="959"
height="192"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Procedure_hu_e90b1bc0403cfc4e.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Procedure_hu_9b5ded020d55e0e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="499"
data-flex-basis="1198px"
&gt;&lt;/p&gt;
&lt;p&gt;事件驱动
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/EventDrivenBack.png"
width="815"
height="137"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/EventDrivenBack_hu_ab9aa5ce39888c5d.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/EventDrivenBack_hu_ba012bb012ca3651.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="594"
data-flex-basis="1427px"
&gt;&lt;/p&gt;
&lt;p&gt;那这两种模式孰优孰劣？看看前人的见解：&lt;/p&gt;
&lt;h1 id="eventdriven-oriented-or-procedure-oriented"&gt;EventDriven-oriented or Procedure-oriented
&lt;/h1&gt;&lt;h2 id="who-are-they"&gt;Who are they
&lt;/h2&gt;&lt;h3 id="event-driven"&gt;Event Driven
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/EventDriven-workers.png"
width="390"
height="176"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/EventDriven-workers_hu_c11e05b94e24b167.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/EventDriven-workers_hu_2d520c7c66ba93a8.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="221"
data-flex-basis="531px"
&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;相对&lt;/strong&gt;较小的进程数量，进程之间进行显式消息通信。针对于事件驱动，有多种实现形式，例如观察者模式或者发布订阅模式等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1. Small number of (relatively static) big processes
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2. Explicit set of message channels
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3. Limited amount of direct sharing of data in memory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;观察者模式&lt;br&gt;
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Observer.png"
width="493"
height="526"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Observer_hu_8df7b65a1e4b6ca5.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Observer_hu_f5cab1a05046fa24.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="93"
data-flex-basis="224px"
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;发布订阅模式
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Publisher-Subscriber.png"
width="640"
height="344"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Publisher-Subscriber_hu_f105db320ffec191.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Publisher-Subscriber_hu_9983713b7f1be770.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="186"
data-flex-basis="446px"
&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;它的特点是事件的产生者并不关心具体的处理逻辑，每个环节的workers都能够专注于自己的工作&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;事件驱动的优点：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1. 解耦：事件发布者、订阅者解耦，其中一个环节的变化，不会影响其他环境的进行
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2. 异步：各个环节通过事件关联，所以服务间不会block。带来执行的可调度性，资源分配的动态性
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3. 灵活：在服务间增加一些适配器（如日志、认证、版本、限流、降级、熔断等）相当容易
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;4. 独立：服务间的吞吐也被解开了，各个服务可以专注于自己的实现，按照自己的处理速度处理
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;5. 缓冲：利用 Broker 或队列的方式还可以达到把抖动的吞吐量变成均匀的吞吐量，这就是所谓的“削峰”，这对后端系统是个不错的保护
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="procedure-oriented"&gt;Procedure-oriented
&lt;/h3&gt;&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Procedure.png"
width="959"
height="192"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Procedure_hu_e90b1bc0403cfc4e.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/Procedure_hu_9b5ded020d55e0e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="499"
data-flex-basis="1198px"
&gt;&lt;/p&gt;
&lt;p&gt;大量快速变化的小进程和基于共享数据的进程同步机制&lt;br&gt;
它的特点是一次请求从一而终，由单一的线程（进程）执行&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1. Large number of very small processes
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2. Rapid creation and deletion of processes
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3. Communication by means of direct sharing of
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;data in memory
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;面向过程的优点：
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;1. 架构简单明了，易于实现
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;2. 各环节在在同一线程/进程内完成，易于追踪(debug)
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;3. 实时性强，任务从一而终
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h2 id="the-duality-mapping"&gt;The Duality Mapping
&lt;/h2&gt;&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/MessageEqualsThread.png"
width="776"
height="477"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/MessageEqualsThread_hu_6a944a6313417065.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/MessageEqualsThread_hu_5f038677b6f137b8.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="162"
data-flex-basis="390px"
&gt;&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-gdscript3" data-lang="gdscript3"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;On&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;Duality&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Operating&lt;/span&gt; &lt;span class="n"&gt;System&lt;/span&gt; &lt;span class="n"&gt;Structures&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;two&lt;/span&gt; &lt;span class="n"&gt;models&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;duals&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;That&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;subsystem&lt;/span&gt; &lt;span class="n"&gt;constructed&lt;/span&gt; &lt;span class="n"&gt;strictly&lt;/span&gt; &lt;span class="n"&gt;according&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;primitives&lt;/span&gt; &lt;span class="n"&gt;defined&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;mapped&lt;/span&gt; &lt;span class="n"&gt;directly&lt;/span&gt; &lt;span class="n"&gt;into&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;dual&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;subsystem&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;fits&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;dual&lt;/span&gt; &lt;span class="n"&gt;programs&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;subsystems&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;logically&lt;/span&gt; &lt;span class="n"&gt;identical&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;They&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;also&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;made&lt;/span&gt; &lt;span class="n"&gt;textually&lt;/span&gt; &lt;span class="n"&gt;very&lt;/span&gt; &lt;span class="n"&gt;similar&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;differing&lt;/span&gt; &lt;span class="n"&gt;only&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;non&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;essential&lt;/span&gt; &lt;span class="n"&gt;details&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;performance&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;program&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;subsystem&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;reflected&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="n"&gt;lengths&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;waiting&lt;/span&gt; &lt;span class="n"&gt;times&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="n"&gt;rates&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;identical&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;dual&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;given&lt;/span&gt; &lt;span class="n"&gt;identical&lt;/span&gt; &lt;span class="n"&gt;scheduling&lt;/span&gt; &lt;span class="n"&gt;strategies&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Furthermore&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;primitive&lt;/span&gt; &lt;span class="n"&gt;operations&lt;/span&gt; &lt;span class="n"&gt;provided&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;operating&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;made&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;efficient&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;their&lt;/span&gt; &lt;span class="n"&gt;duals&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="err"&gt;两类模型互为对偶，两者可以互相转换。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="err"&gt;逻辑上两者彼此相似，甚至可以在文本上表现得非常相似，除了非必要的细节上。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="err"&gt;在相同的调度策略下，两类模型的性能可以一样高（根据队列长度、等待时间、处理速度等方面观测）。除此之外，一个模型提供的基本操作可以使其效率和另一个模型一样高。&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="event-driven-simpler-concurrency-model"&gt;Event Driven: simpler concurrency model
&lt;/h3&gt;&lt;details&gt;
&lt;summary&gt;原文&lt;/summary&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Messages and message identifiers. A message is a data structure meant for sending information from one process to another; it typically contains a small, fixed area for data which is passed by value and space for a pointer to larger data structures which must be passed by reference. A message identifier is a handle by which a particular message can be identified.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Message channels and message ports. A message channel is an abstract structure which identifies the destination of a message. A message port is queue capable of holding messages of a certain class or type which might be received by a particular process. Each message channel must be bound to a particular message port before is can be used. A message port, however, may have more than one message channel bound to it.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Four message transmission operations:
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 1. SendMessage[messageChannel, messageBody] returns [messageId]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; This operation simply queues a new message on the port bound to the the messageChannel named as parameter.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; The messageld returned is used as parameter to the following operation.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 2. AwaitReply(messageId] returns [messageBody]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; The operation causes the process to wait for a reply to a specific message previously sent via SendMessage.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 3. WaitForMessage[set of messagePort] returns [messageBody, messageld, messagePort]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; This operation allows a process to wait for a new (unsolicited) message on any one of the message ports named in the &amp;#39;parameter.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; The message which is first on the queue is returned, along with a message identifier for future reference and an indication of the port from which that message came.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; 4. SendReply[messageId, messageBody]
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; This operation sends a reply to the particular message identified by the message identifier.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;SKIP FIGURE
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;In this process, the kind of service requested is a function of which port the requesting message arrives on. It may or may not involve making requests of still other processes and/or sending a reply back to the requestor. It may also result in some circumstance, such as the exhaustion of a resource, which prevents further requests from being considered. These remain queued on their port until later, when the process is willing to listen on that port again.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Note that if a whole system is built according to this style, then the sole means of interaction among the components of that system is by means of the message facility. Each process can operate in its own address space without interference from the others. Because of the serial way in which requests are handled, there is never any need to protect the state information of a process from multiple, simultaneous access and updating.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h4 id="一些概念的定义"&gt;一些概念的定义：
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Messages: 数据结构，用于进程之间传递信息。&lt;br&gt;
Message identifiers: 消息 id&lt;br&gt;
Message channels: 消息目的地&lt;br&gt;
Message ports: 接收端口&lt;/p&gt;&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;SendMessage [messageChannel, messageBody] returns [messageId]&lt;br&gt;
AwaitReply [messageId] returns [messageBody]
WaitForMessage [set of messagePort] returns [messageBody, messageld, messagePort]
SendReply [messageId, messageBody]&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/MessageDefinition.png"
width="777"
height="236"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/MessageDefinition_hu_cda856c528e6f3a8.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/MessageDefinition_hu_16a9549f1d611b2e.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="329"
data-flex-basis="790px"
&gt;&lt;/p&gt;
&lt;h4 id="运行公式"&gt;运行公式
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;begin m: messageBody;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; i: messageld;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; p: portid;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; s: set of portid;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ... -local data and state information for this process
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; initialize;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; do forever;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; [m, i, p] &amp;lt;- WaitForMessage[s];
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; case p of
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; port1 =&amp;gt;...; -algorithm for port1
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; port2 =&amp;gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; if resourceExhausted then
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; s &amp;lt;- s - port2;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; SendReply[i, reply];
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ...; -algorithm for port2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; portk =&amp;gt;...
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; s &amp;lt;- s + port2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ...; -algorithm for portk
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; endcase;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; endloop;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;end.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="procedure-oriented-simpler--natural-programming-style"&gt;Procedure-oriented: simpler &amp;amp; natural programming style
&lt;/h3&gt;&lt;details&gt;
&lt;summary&gt;原文&lt;/summary&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-gdscript3" data-lang="gdscript3"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;1.&lt;/span&gt; &lt;span class="n"&gt;Procedures&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;piece&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;containing&lt;/span&gt; &lt;span class="n"&gt;algorithms&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;local&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt; &lt;span class="n"&gt;always&lt;/span&gt; &lt;span class="n"&gt;operates&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt; &lt;span class="n"&gt;access&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt; &lt;span class="n"&gt;global&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;declared&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;well&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt; &lt;span class="n"&gt;containing&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;2.&lt;/span&gt; &lt;span class="n"&gt;Procedure&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;facilities&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;synchronous&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;asynchronous&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;synchronous&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;mechanism&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;just&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;ordinary&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;very&lt;/span&gt; &lt;span class="n"&gt;much&lt;/span&gt; &lt;span class="n"&gt;like&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;Algol&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Pascal&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;etc&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;asynchronous&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;mechanism&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;represented&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;FORK&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;JOIN&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;defmed&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;follows&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;processld&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;FORK&lt;/span&gt; &lt;span class="n"&gt;procedureName&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;parameterList&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt; &lt;span class="n"&gt;starts&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;executing&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;own&lt;/span&gt; &lt;span class="n"&gt;parameters&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;operates&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;declaration&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;just&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;had&lt;/span&gt; &lt;span class="n"&gt;been&lt;/span&gt; &lt;span class="n"&gt;called&lt;/span&gt; &lt;span class="n"&gt;synchronously&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;but&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;own&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;stack&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;state&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;calling&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;continues&lt;/span&gt; &lt;span class="n"&gt;executing&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;FORK&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt; &lt;span class="n"&gt;returned&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;FORK&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;resultList&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="n"&gt;JOIN&lt;/span&gt; &lt;span class="n"&gt;processld&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt; &lt;span class="n"&gt;causes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;executing&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;synchronize&lt;/span&gt; &lt;span class="n"&gt;itself&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;termination&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;named&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;identifier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;results&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;retrieved&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;returned&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;calling&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;they&lt;/span&gt; &lt;span class="n"&gt;had&lt;/span&gt; &lt;span class="n"&gt;been&lt;/span&gt; &lt;span class="n"&gt;returned&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;ordinary&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;JOlNed&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;destroyed&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;execution&lt;/span&gt; &lt;span class="n"&gt;continues&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;JOlNing&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt; &lt;span class="n"&gt;following&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;JOIN&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;3.&lt;/span&gt; &lt;span class="n"&gt;Modules&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;monitors&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;primitive&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;unit&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;compilation&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;consists&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;collection&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;scope&lt;/span&gt; &lt;span class="n"&gt;rules&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;language&lt;/span&gt; &lt;span class="n"&gt;determine&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;these&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;accessible&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;callable&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;outside&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;A&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;special&lt;/span&gt; &lt;span class="n"&gt;kind&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;associated&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;prevent&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;than&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;executing&lt;/span&gt; &lt;span class="n"&gt;inside&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;at&lt;/span&gt; &lt;span class="n"&gt;any&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;It&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;based&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;very&lt;/span&gt; &lt;span class="n"&gt;similar&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;mechanism&lt;/span&gt; &lt;span class="n"&gt;described&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;Hoare&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;4.&lt;/span&gt; &lt;span class="n"&gt;Module&lt;/span&gt; &lt;span class="n"&gt;instantiation&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Modules&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;including&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;instantiated&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;Mesa&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;means&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;NEW&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;START&lt;/span&gt; &lt;span class="n"&gt;statements&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;These&lt;/span&gt; &lt;span class="n"&gt;cause&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;holding&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;provide&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;binding&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;external&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;references&lt;/span&gt; &lt;span class="n"&gt;within&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="n"&gt;declared&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;modules&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;activate&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;initialization&lt;/span&gt; &lt;span class="n"&gt;code&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="mf"&gt;5.&lt;/span&gt; &lt;span class="n"&gt;Condition&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Condition&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;part&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;Hoare&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;s monitor mechanism an provide more flexible synchronization among events than mutual exclusion facility of the monitor lock or the process termination facility of the JOIN statement. In our model, a condition variable, must be contained within a monitor, has associated with it a queue of processes, and has two operations defined on it:&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;WAIT&lt;/span&gt; &lt;span class="n"&gt;conditionVariable&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;causes&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;executing&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;suspend&lt;/span&gt; &lt;span class="n"&gt;execution&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;queue&lt;/span&gt; &lt;span class="n"&gt;associated&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;SIGNAL&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;Variable&lt;/span&gt; &lt;span class="o"&gt;--&lt;/span&gt; &lt;span class="n"&gt;This&lt;/span&gt; &lt;span class="n"&gt;causes&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;previously&lt;/span&gt; &lt;span class="n"&gt;WAITed&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;resume&lt;/span&gt; &lt;span class="n"&gt;execution&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;next&lt;/span&gt; &lt;span class="n"&gt;statement&lt;/span&gt; &lt;span class="n"&gt;when&lt;/span&gt; &lt;span class="n"&gt;it&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;able&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;reclaim&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;Note&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;because&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;FORK&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;JOIN&lt;/span&gt; &lt;span class="n"&gt;operations&lt;/span&gt; &lt;span class="n"&gt;apply&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;already&lt;/span&gt; &lt;span class="n"&gt;declared&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;bound&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;these&lt;/span&gt; &lt;span class="n"&gt;operations&lt;/span&gt; &lt;span class="n"&gt;take&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;same&lt;/span&gt; &lt;span class="n"&gt;order&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;magnitude&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;time&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;execute&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt; &lt;span class="n"&gt;simple&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;returns&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Thus&lt;/span&gt; &lt;span class="n"&gt;processes&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;very&lt;/span&gt; &lt;span class="n"&gt;lightweight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;created&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;destroyed&lt;/span&gt; &lt;span class="n"&gt;very&lt;/span&gt; &lt;span class="n"&gt;frequently&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Module&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;instantiation&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;hand&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;cumbersome&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;usually&lt;/span&gt; &lt;span class="n"&gt;done&lt;/span&gt; &lt;span class="n"&gt;statically&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;started&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Note&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;canonical&lt;/span&gt; &lt;span class="n"&gt;model&lt;/span&gt; &lt;span class="n"&gt;has&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;deletion&lt;/span&gt; &lt;span class="n"&gt;facility&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;SKIP&lt;/span&gt; &lt;span class="n"&gt;FIGURE&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;The&lt;/span&gt; &lt;span class="n"&gt;attribute&lt;/span&gt; &lt;span class="n"&gt;ENTRY&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;distinguish&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;called&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;outside&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;thus&lt;/span&gt; &lt;span class="n"&gt;seizing&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;lock&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;those&lt;/span&gt; &lt;span class="n"&gt;which&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;declared&lt;/span&gt; &lt;span class="n"&gt;purely&lt;/span&gt; &lt;span class="n"&gt;internal&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Any&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;may&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;course&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;procedures&lt;/span&gt; &lt;span class="n"&gt;declared&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;modules&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;services&lt;/span&gt; &lt;span class="n"&gt;before&lt;/span&gt; &lt;span class="n"&gt;returning&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Within&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;control&lt;/span&gt; &lt;span class="n"&gt;waiting&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;circumstances&lt;/span&gt; &lt;span class="n"&gt;such&lt;/span&gt; &lt;span class="n"&gt;as&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;availability&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;resources&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;These&lt;/span&gt; &lt;span class="n"&gt;are&lt;/span&gt; &lt;span class="n"&gt;used&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;standard&lt;/span&gt; &lt;span class="n"&gt;resource&lt;/span&gt; &lt;span class="n"&gt;manager&lt;/span&gt; &lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;tp&lt;/span&gt; &lt;span class="n"&gt;control&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;access&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;representing&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;particular&lt;/span&gt; &lt;span class="n"&gt;kind&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;&lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;whole&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;built&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;then&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;sole&lt;/span&gt; &lt;span class="n"&gt;means&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;interaction&lt;/span&gt; &lt;span class="n"&gt;among&lt;/span&gt; &lt;span class="n"&gt;its&lt;/span&gt; &lt;span class="n"&gt;components&lt;/span&gt; &lt;span class="n"&gt;is&lt;/span&gt; &lt;span class="n"&gt;procedural&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Processes&lt;/span&gt; &lt;span class="n"&gt;move&lt;/span&gt; &lt;span class="n"&gt;from&lt;/span&gt; &lt;span class="n"&gt;one&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;another&lt;/span&gt; &lt;span class="n"&gt;by&lt;/span&gt; &lt;span class="n"&gt;means&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;procedure&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;facility&lt;/span&gt; &lt;span class="n"&gt;across&lt;/span&gt; &lt;span class="n"&gt;module&lt;/span&gt; &lt;span class="n"&gt;boundaries&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;they&lt;/span&gt; &lt;span class="n"&gt;use&lt;/span&gt; &lt;span class="n"&gt;asynchronous&lt;/span&gt; &lt;span class="n"&gt;calls&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;stimulate&lt;/span&gt; &lt;span class="n"&gt;concurrent&lt;/span&gt; &lt;span class="n"&gt;activity&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;They&lt;/span&gt; &lt;span class="n"&gt;depend&lt;/span&gt; &lt;span class="n"&gt;upon&lt;/span&gt; &lt;span class="n"&gt;monitor&lt;/span&gt; &lt;span class="n"&gt;locks&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;condition&lt;/span&gt; &lt;span class="n"&gt;variables&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;keep&lt;/span&gt; &lt;span class="n"&gt;out&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;way&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;each&lt;/span&gt; &lt;span class="n"&gt;other&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="n"&gt;Thus&lt;/span&gt; &lt;span class="n"&gt;no&lt;/span&gt; &lt;span class="n"&gt;process&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;associated&lt;/span&gt; &lt;span class="n"&gt;with&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;single&lt;/span&gt; &lt;span class="n"&gt;address&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;unless&lt;/span&gt; &lt;span class="n"&gt;that&lt;/span&gt; &lt;span class="n"&gt;space&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;whole&lt;/span&gt; &lt;span class="n"&gt;system&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h4 id="一些概念的定义-1"&gt;一些概念的定义
&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;Procedure&lt;br&gt;
Procedure call facilities, synchronous and asynchronous&lt;br&gt;
&amp;ndash; (asynchronous):&lt;br&gt;
&amp;mdash;- processld &amp;lt;- FORK procedureName[parameterList]&lt;br&gt;
&amp;mdash;- [resultList] &amp;lt;- JOIN processld&lt;br&gt;
Modules: consists of a collection of procedures and data&lt;br&gt;
Monitors: 监控锁防止多进程在其中执行&lt;br&gt;
Module instantiation: 实例化&lt;br&gt;
Condition variables:&lt;br&gt;
&amp;ndash; WAIT condition Variable&lt;br&gt;
&amp;ndash; SIGNAL condition Variable&lt;/p&gt;&lt;/blockquote&gt;
&lt;h4 id="运行公式-1"&gt;运行公式
&lt;/h4&gt;&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt; 1
&lt;/span&gt;&lt;span class="lnt"&gt; 2
&lt;/span&gt;&lt;span class="lnt"&gt; 3
&lt;/span&gt;&lt;span class="lnt"&gt; 4
&lt;/span&gt;&lt;span class="lnt"&gt; 5
&lt;/span&gt;&lt;span class="lnt"&gt; 6
&lt;/span&gt;&lt;span class="lnt"&gt; 7
&lt;/span&gt;&lt;span class="lnt"&gt; 8
&lt;/span&gt;&lt;span class="lnt"&gt; 9
&lt;/span&gt;&lt;span class="lnt"&gt;10
&lt;/span&gt;&lt;span class="lnt"&gt;11
&lt;/span&gt;&lt;span class="lnt"&gt;12
&lt;/span&gt;&lt;span class="lnt"&gt;13
&lt;/span&gt;&lt;span class="lnt"&gt;14
&lt;/span&gt;&lt;span class="lnt"&gt;15
&lt;/span&gt;&lt;span class="lnt"&gt;16
&lt;/span&gt;&lt;span class="lnt"&gt;17
&lt;/span&gt;&lt;span class="lnt"&gt;18
&lt;/span&gt;&lt;span class="lnt"&gt;19
&lt;/span&gt;&lt;span class="lnt"&gt;20
&lt;/span&gt;&lt;span class="lnt"&gt;21
&lt;/span&gt;&lt;span class="lnt"&gt;22
&lt;/span&gt;&lt;span class="lnt"&gt;23
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ResourceManager: MONITOR =
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; C: CONDITION;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; resourceExhausted: BOOLEAN;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ... -global data and state information for this process
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; proc1: ENTRY PROCEDURE[...] =
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ...; -algorithm for prod
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; proc2: ENTRY PROCEDURE[...] RETURNS[...] =
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; BEGIN
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; IF resourceExhausted THEN WAIT c;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; •••;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; RETURN[results];
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; •••;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; END; -algorithm for proc2
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; procL: ENTRY PROCEDURE[...] =
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; BEGIN
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; resourceExhausted &amp;lt;- FALSE;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; SIGNAL C;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; ...;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; END; -algorithm for procL endloop;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; endloop;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt; initialize;
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;END
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;h3 id="the-duality-mapping-1"&gt;The Duality Mapping
&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Processes, CreateProcess&lt;/td&gt;
&lt;td&gt;Monitors, NEW/START&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message Channels&lt;/td&gt;
&lt;td&gt;External Procedure identifiers&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Message Ports&lt;/td&gt;
&lt;td&gt;ENTRY procedure identifier&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendMessage; AwaitReply (immediate)&lt;/td&gt;
&lt;td&gt;simple procedure call&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendMessage; AwaitReply (delayed)&lt;/td&gt;
&lt;td&gt;fork;join&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendReply&lt;/td&gt;
&lt;td&gt;RETURN (from procedure)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;main loop of standard resource manager, WaitForMessage statement, case statement&lt;/td&gt;
&lt;td&gt;monitor lock, ENTRY attribute&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;arms of the case statement&lt;/td&gt;
&lt;td&gt;ENTRY procedure declaration&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;selective waiting for messages&lt;/td&gt;
&lt;td&gt;condition variables, WAIT, SIGNAL&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingServers.png"
width="912"
height="465"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingServers_hu_a6817f47d7805267.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingServers_hu_18767011346240d2.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="196"
data-flex-basis="470px"
&gt;
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingClients.png"
width="885"
height="458"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingClients_hu_1f6a53dc96926f4f.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingClients_hu_b98f4620001e6896.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="193"
data-flex-basis="463px"
&gt;
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingCodes.png"
width="913"
height="473"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingCodes_hu_cd284acfa380824b.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingCodes_hu_3172d61bf18f7dd5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="193"
data-flex-basis="463px"
&gt;&lt;/p&gt;
&lt;h4 id="番外"&gt;番外
&lt;/h4&gt;&lt;p&gt;在之后的另一篇文章，Why Events Are A Bad Idea 里面，作者的解释性对比&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;event handlers&lt;/td&gt;
&lt;td&gt;monitors&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;events accepted by a handler&lt;/td&gt;
&lt;td&gt;functions exported by a module&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendMessage、AwaitReply&lt;/td&gt;
&lt;td&gt;procedure call, or fork/join&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SendReply&lt;/td&gt;
&lt;td&gt;return from procedure&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;waiting for messages&lt;/td&gt;
&lt;td&gt;waiting on condition variables&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id="性能"&gt;性能
&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;程序本身执行时间
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingCodes.png"
width="913"
height="473"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingCodes_hu_cd284acfa380824b.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/DualityMappingCodes_hu_3172d61bf18f7dd5.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="193"
data-flex-basis="463px"
&gt;&lt;/li&gt;
&lt;li&gt;调用系统操作开销（可以理解为调用第三方开销？）
&lt;img src="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/SystemCall.png"
width="519"
height="247"
srcset="https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/SystemCall_hu_d8dd1674f2902b85.png 480w, https://MyLoveES.github.io/p/%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8-or-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/SystemCall_hu_de6d54ff6c69bf88.png 1024w"
loading="lazy"
class="gallery-image"
data-flex-grow="210"
data-flex-basis="504px"
&gt;&lt;/li&gt;
&lt;li&gt;队列等待时间（反映的是阻塞、资源竞争、调度策略）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;二元性变换使构成系统的程序主体不受影响。因此，所有的算法将以相同的速度计算，并且在每个数据结构中存储相同数量的信息。在每个系统中执行的代码数量相同。将执行相同数量的加法、乘法、比较和字符串操作。因此，如果基本的处理器特性没有改变，那么这些特性将需要相同数量的计算能力，并且系统性能的这个组件将保持不变。同样，对于系统调用开销和队列阻塞等待，两者会付出同样的代价。&lt;/p&gt;
&lt;details&gt;
&lt;summary&gt;原文&lt;/summary&gt;
&lt;div class="highlight"&gt;&lt;div class="chroma"&gt;
&lt;table class="lntable"&gt;&lt;tr&gt;&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code&gt;&lt;span class="lnt"&gt;1
&lt;/span&gt;&lt;span class="lnt"&gt;2
&lt;/span&gt;&lt;span class="lnt"&gt;3
&lt;/span&gt;&lt;span class="lnt"&gt;4
&lt;/span&gt;&lt;span class="lnt"&gt;5
&lt;/span&gt;&lt;span class="lnt"&gt;6
&lt;/span&gt;&lt;span class="lnt"&gt;7
&lt;/span&gt;&lt;span class="lnt"&gt;8
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;
&lt;td class="lntd"&gt;
&lt;pre tabindex="0" class="chroma"&gt;&lt;code class="language-fallback" data-lang="fallback"&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;The duality transformation leaves the main bodies of the programs comprising the system untouched. Thus the algorithms will all compute at the same speed, and the same amount of information will be stored in each data structure. The same amount of client code will be executed in each of the dual systems. The same number of additions, multiplications, comparisons, -and string operations will be performed. Therefore if basic processor characteristics are unchanged, then these will take precisely the same amount of computing power, and this component of the system performance will remain unchanged.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;The other component affecting the speed of execution of a single program is the time it takes to execute each of the primitive system operations it calls. We assert without proof that the facilities of each of our two canonical models can be made to execute as efficiently as the corresponding facilities of the other model. I.e.,
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Sending a message, with its inherent need to allocate a message block and manipulate a queue and its possibility of forcing a context (process) switch, is a computation of the same complexity as that of calling or FOR King to an ENTRY procedure, which involves the same need to allocate, queue, and force a context switch.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Leaving a monitor, with the possibility of having to unqueue a waiting process and re-enter it, is an operation of the same complexity as that of waiting for new messages.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Process switching can be made equally fast in either system, and for similar machine architectures this means saving the same amount of state information. The same is true for the scheduling and dispatching of processes at the &amp;#39;microscopic&amp;#39; level.
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;14
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;ON THE DUALITY OF OPERATING SYSTEM STRUCTURES
&lt;/span&gt;&lt;/span&gt;&lt;span class="line"&gt;&lt;span class="cl"&gt;Virtual memory and paging or swapping can even be used with equal effectiveness in either model.
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/details&gt;
&lt;h2 id="but-who-is-better-"&gt;But, who is better ?
&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;ref: &lt;a class="link" href="https://www.cc.gatech.edu/classes/AY2010/cs4210_fall/papers/ousterhout-threads.pdf" target="_blank" rel="noopener"
&gt;Why Threads Are a Bad Idea&lt;/a&gt;
ref: &lt;a class="link" href="http://capriccio.cs.berkeley.edu/pubs/threads-hotos-2003.pdf" target="_blank" rel="noopener"
&gt;Why events are a bad idea&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;
&lt;h1 id="ref"&gt;Ref
&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;ref: &lt;a class="link" href="https://courses.cs.vt.edu/~cs5204/fall07-gback/papers/p3-lauer.pdf" target="_blank" rel="noopener"
&gt;On the Duality of Operating System Structures&lt;/a&gt;&lt;/p&gt;&lt;/blockquote&gt;</description></item></channel></rss>