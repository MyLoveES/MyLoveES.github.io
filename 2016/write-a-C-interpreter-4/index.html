<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>手把手教你构建 C 语言编译器（4）- 递归下降 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/C/" rel="tag">C</a><a class="post-tag-link" href="/tags/compiler/" rel="tag">compiler</a></div><div class="post-time">2016-01-02</div></div></div><div class="container post-header"><h1>手把手教你构建 C 语言编译器（4）- 递归下降</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是递归下降"><span class="toc-number">1.</span> <span class="toc-text">什么是递归下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#终结符与非终结符"><span class="toc-number">2.</span> <span class="toc-text">终结符与非终结符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四则运算的递归下降"><span class="toc-number">3.</span> <span class="toc-text">四则运算的递归下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么选择递归下降"><span class="toc-number">4.</span> <span class="toc-text">为什么选择递归下降</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#左递归"><span class="toc-number">5.</span> <span class="toc-text">左递归</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#四则运算的实现"><span class="toc-number">6.</span> <span class="toc-text">四则运算的实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">7.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>本章我们将讲解递归下降的方法，并用它完成一个基本的四则运算的语法分析器。</p>
<a id="more"></a>
<p>手把手教你构建 C 语言编译器系列共有10个部分：</p>
<ol>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-0/">手把手教你构建 C 语言编译器（0）——前言</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-1/">手把手教你构建 C 语言编译器（1）——设计</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-2/">手把手教你构建 C 语言编译器（2）——虚拟机</a></li>
<li><a href="http://lotabout.me/2015/write-a-C-interpreter-3/">手把手教你构建 C 语言编译器（3）——词法分析器</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-4/">手把手教你构建 C 语言编译器（4）——递归下降</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-5/">手把手教你构建 C 语言编译器（5）——变量定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-6/">手把手教你构建 C 语言编译器（6）——函数定义</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-7/">手把手教你构建 C 语言编译器（7）——语句</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-8/">手把手教你构建 C 语言编译器（8）——表达式</a></li>
<li><a href="http://lotabout.me/2016/write-a-C-interpreter-9/">手把手教你构建 C 语言编译器（9）——总结</a></li>
</ol>
<h2 id="什么是递归下降"><a class="header-anchor" href="#什么是递归下降"></a>什么是递归下降</h2>
<p>传统上，编写语法分析器有两种方法，一种是自顶向下，一种是自底向上。自顶向下是从起始非终结符开始，不断地对非终结符进行分解，直到匹配输入的终结符；自底向上是不断地将终结符进行合并，直到合并成起始的非终结符。</p>
<p>其中的自顶向下方法就是我们所说的递归下降。</p>
<h2 id="终结符与非终结符"><a class="header-anchor" href="#终结符与非终结符"></a>终结符与非终结符</h2>
<p>没有学过编译原理的话可能并不知道什么是“终结符”，“非终结符”。这里我简单介绍一下。首先是 <a href="https://zh.wikipedia.org/wiki/%E5%B7%B4%E7%A7%91%E6%96%AF%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener">BNF</a> 范式，就是一种用来描述语法的语言，例如，四则运算的规则可以表示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::&#x3D; &lt;expr&gt; + &lt;term&gt;</span><br><span class="line">         | &lt;expr&gt; - &lt;term&gt;</span><br><span class="line">         | &lt;term&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::&#x3D; &lt;term&gt; * &lt;factor&gt;</span><br><span class="line">         | &lt;term&gt; &#x2F; &lt;factor&gt;</span><br><span class="line">         | &lt;factor&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::&#x3D; ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure>
<p>用尖括号 <code>&lt;&gt;</code> 括起来的就称作 <strong>非终结符</strong> ，因为它们可以用 <code>::=</code> 右侧的式子代替。<code>|</code> 表示选择，如 <code>&lt;expr&gt;</code> 可以是 <code>&lt;expr&gt; + &lt;term&gt;</code>、<code>&lt;expr&gt; - &lt;term&gt;</code>或
<code>&lt;term&gt;</code> 中的一种。而没有出现在<code>::=</code>左边的就称作 <strong>终结符</strong> ，一般终结符对应于词法分析器输出的标记。</p>
<h2 id="四则运算的递归下降"><a class="header-anchor" href="#四则运算的递归下降"></a>四则运算的递归下降</h2>
<p>例如，我们对 <code>3 * (4 + 2)</code> 进行语法分析。我们假设词法分析器已经正确地将其中的数字识别成了标记 <code>Num</code>。</p>
<p>递归下降是从起始的非终结符开始（顶），本例中是 <code>&lt;expr&gt;</code>，实际中可以自己指定，不指定的话一般认为是第一个出现的非终结符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. &lt;expr&gt; &#x3D;&gt; &lt;expr&gt;</span><br><span class="line">2.           &#x3D;&gt; &lt;term&gt;        * &lt;factor&gt;</span><br><span class="line">3.              &#x3D;&gt; &lt;factor&gt;     |</span><br><span class="line">4.                 &#x3D;&gt; Num (3)   |</span><br><span class="line">5.                              &#x3D;&gt; ( &lt;expr&gt; )</span><br><span class="line">6.                                   &#x3D;&gt; &lt;expr&gt;           + &lt;term&gt;</span><br><span class="line">7.                                      &#x3D;&gt; &lt;term&gt;          |</span><br><span class="line">8.                                         &#x3D;&gt; &lt;factor&gt;     |</span><br><span class="line">9.                                            &#x3D;&gt; Num (4)   |</span><br><span class="line">10.                                                        &#x3D;&gt; &lt;factor&gt;</span><br><span class="line">11.                                                           &#x3D;&gt; Num (2)</span><br></pre></td></tr></table></figure>
<p>可以看到，整个解析的过程是在不断对非终结符进行替换（向下），直到遇见了终结符（底）。而我们可以从解析的过程中看出，一些非终结符如<code>&lt;expr&gt;</code>被递归地使用了。</p>
<h2 id="为什么选择递归下降"><a class="header-anchor" href="#为什么选择递归下降"></a>为什么选择递归下降</h2>
<p>从上小节对四则运算的递归下降解析可以看出，整个解析的过程和语法的 BNF 表示是十分接近的，更为重要的是，我们可以很容易地直接将 BNF 表示转换成实际的代码。方法是为每个产生式（即 <code>非终结符 ::= ...</code>）生成一个同名的函数。</p>
<p>这里会有一个疑问，就是上例中，当一个终结符有多个选择时，如何确定具体选择哪一个？如为什么用 <code>&lt;expr&gt; ::= &lt;term&gt; * &lt;factor&gt;</code> 而不是 <code>&lt;expr&gt; ::= &lt;term&gt; / &lt;factor&gt;</code>
？这就用到了上一章中提到的“向前看 k 个标记”的概念了。我们向前看一个标记，发现是 <code>*</code>，而这个标记足够让我们确定用哪个表达式了。</p>
<p>另外，递归下下降方法对 BNF 方法本身有一定的要求，否则会有一些问题，如经典的“左递归”问题。</p>
<h2 id="左递归"><a class="header-anchor" href="#左递归"></a>左递归</h2>
<p>原则上我们是不讲这么深入，但我们上面的四则运算的文法就是左递归的，而左递归的语法是没法直接使用递归下降的方法实现的。因此我们要消除左递归，消除后的文法如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;expr&gt; ::&#x3D; &lt;term&gt; &lt;expr_tail&gt;</span><br><span class="line">&lt;expr_tail&gt; ::&#x3D; + &lt;term&gt; &lt;expr_tail&gt;</span><br><span class="line">              | - &lt;term&gt; &lt;expr_tail&gt;</span><br><span class="line">              | &lt;empty&gt;</span><br><span class="line"></span><br><span class="line">&lt;term&gt; ::&#x3D; &lt;factor&gt; &lt;term_tail&gt;</span><br><span class="line">&lt;term_tail&gt; ::&#x3D; * &lt;factor&gt; &lt;term_tail&gt;</span><br><span class="line">              | &#x2F; &lt;factor&gt; &lt;term_tail&gt;</span><br><span class="line">              | &lt;empty&gt;</span><br><span class="line"></span><br><span class="line">&lt;factor&gt; ::&#x3D; ( &lt;expr&gt; )</span><br><span class="line">           | Num</span><br></pre></td></tr></table></figure>
<p>消除左递归的相关方法，这里不再多说，请自行查阅相关的资料。</p>
<h2 id="四则运算的实现"><a class="header-anchor" href="#四则运算的实现"></a>四则运算的实现</h2>
<p>本节中我们专注语法分析器部分的实现，具体实现很容易，我们直接贴上代码，就是上述的消除左递归后的文法直接转换而来的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expr</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">factor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">'('</span>) &#123;</span><br><span class="line">        match(<span class="string">'('</span>);</span><br><span class="line">        value = expr();</span><br><span class="line">        match(<span class="string">')'</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        value = token_val;</span><br><span class="line">        match(Num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">term_tail</span><span class="params">(<span class="keyword">int</span> lvalue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">'*'</span>) &#123;</span><br><span class="line">        match(<span class="string">'*'</span>);</span><br><span class="line">        <span class="keyword">int</span> value = lvalue * factor();</span><br><span class="line">        <span class="keyword">return</span> term_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'/'</span>) &#123;</span><br><span class="line">        match(<span class="string">'/'</span>);</span><br><span class="line">        <span class="keyword">int</span> value = lvalue / factor();</span><br><span class="line">        <span class="keyword">return</span> term_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lvalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">term</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lvalue = factor();</span><br><span class="line">    <span class="keyword">return</span> term_tail(lvalue);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expr_tail</span><span class="params">(<span class="keyword">int</span> lvalue)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token == <span class="string">'+'</span>) &#123;</span><br><span class="line">        match(<span class="string">'+'</span>);</span><br><span class="line">        <span class="keyword">int</span> value = lvalue + term();</span><br><span class="line">        <span class="keyword">return</span> expr_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token == <span class="string">'-'</span>) &#123;</span><br><span class="line">        match(<span class="string">'-'</span>);</span><br><span class="line">        <span class="keyword">int</span> value = lvalue - term();</span><br><span class="line">        <span class="keyword">return</span> expr_tail(value);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> lvalue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">expr</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lvalue = term();</span><br><span class="line">    <span class="keyword">return</span> expr_tail(lvalue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，有了BNF方法后，采用递归向下的方法来实现编译器是很直观的。</p>
<p>我们把词法分析器的代码一并贴上：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">#<span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> &#123;Num&#125;;</span><br><span class="line"><span class="keyword">int</span> token;</span><br><span class="line"><span class="keyword">int</span> token_val;</span><br><span class="line"><span class="keyword">char</span> *<span class="built_in">line</span> = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> *src = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// skip white space</span></span><br><span class="line">    <span class="keyword">while</span> (*src == <span class="string">' '</span> || *src == <span class="string">'\t'</span>) &#123;</span><br><span class="line">        src ++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    token = *src++;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (token &gt;= <span class="string">'0'</span> &amp;&amp; token &lt;= <span class="string">'9'</span> ) &#123;</span><br><span class="line">        token_val = token - <span class="string">'0'</span>;</span><br><span class="line">        token = Num;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (*src &gt;= <span class="string">'0'</span> &amp;&amp; *src &lt;= <span class="string">'9'</span>) &#123;</span><br><span class="line">            token_val = token_val*<span class="number">10</span> + *src - <span class="string">'0'</span>;</span><br><span class="line">            src ++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">int</span> tk)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (token != tk) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"expected token: %d(%c), got: %d(%c)\n"</span>, tk, tk, token, token);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后是<code>main</code>函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> linecap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">ssize_t</span> linelen;</span><br><span class="line">    <span class="keyword">while</span> ((linelen = getline(&amp;<span class="built_in">line</span>, &amp;linecap, <span class="built_in">stdin</span>)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        src = <span class="built_in">line</span>;</span><br><span class="line">        next();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, expr());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>本章中我们介绍了递归下降的方法，并用它来实现了四则运算的语法分析器。</p>
<p>花这么大精力讲解递归下降方法，是因为几乎所有手工编写的语法分析器都或多或少地有它的影子。换句话说，掌握了递归下降的方法，就可以应付大多数的语法分析器编写。</p>
<p>同时我们也用实例看到了理论（BNF 语法，左递归的消除）是如何帮助我们的工程实现的。尽管理论不是必需的，但如果能掌握它，对于提高我们的水平还是很有帮助的。</p></div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'lotaboutlife';
var disqus_identifier = '2016/write-a-C-interpreter-4/';
var disqus_title = '手把手教你构建 C 语言编译器（4）- 递归下降';
var disqus_url = 'https://lotabout.me/2016/write-a-C-interpreter-4/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>