<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="&lt;p&gt;常见的权限认证是通过提供“用户名密码”完成，业务中有一些 API，我们希望以 API
Token 的形式验证。例如 URL 上加上 token &lt;code&gt;/api?token=xxxx&lt;/code&gt; 就允许API 的访问。这种设计背后的逻辑是用户名密码拥有较高的权限，而 API token 可以只给出某个子系统的权限，类似于 Github 的 &lt;a href=&quot;https://github.blog/2013-05-16-personal-api-tokens/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Personal API
Tokens&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;本文会介绍如何用 Spring Security 来实现。Spring Security 虽然功能强大，但配置起来经常让人云里雾里，所以我们要试图了解一些 Spring Security 的工作原理，再具体实现 API Token 的权限认证。&lt;/p&gt;"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Spring Security 实现 API Token 权限认证 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/Security/" rel="tag">Security</a><a class="post-tag-link" href="/tags/Spring/" rel="tag">Spring</a></div><div class="post-time">2019-02-18</div></div></div><div class="container post-header"><h1>Spring Security 实现 API Token 权限认证</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-security-基本原理"><span class="toc-number">1.</span> <span class="toc-text">Spring Security 基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认证-authentication"><span class="toc-number">1.1.</span> <span class="toc-text">认证(Authentication)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#授权-authorization"><span class="toc-number">1.2.</span> <span class="toc-text">授权(Authorization)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#配置"><span class="toc-number">1.3.</span> <span class="toc-text">配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#api-token-实现"><span class="toc-number">2.</span> <span class="toc-text">API Token 实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#认证信息"><span class="toc-number">2.1.</span> <span class="toc-text">认证信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽取-token-的过滤器"><span class="toc-number">2.2.</span> <span class="toc-text">抽取 token 的过滤器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#校验逻辑"><span class="toc-number">2.3.</span> <span class="toc-text">校验逻辑</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#错误处理"><span class="toc-number">2.4.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#组装配置"><span class="toc-number">2.5.</span> <span class="toc-text">组装配置</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参考"><span class="toc-number">4.</span> <span class="toc-text">参考</span></a></li></ol></details></div><div class="container post-content"><p>常见的权限认证是通过提供“用户名密码”完成，业务中有一些 API，我们希望以 API
Token 的形式验证。例如 URL 上加上 token <code>/api?token=xxxx</code> 就允许API 的访问。这种设计背后的逻辑是用户名密码拥有较高的权限，而 API token 可以只给出某个子系统的权限，类似于 Github 的 <a href="https://github.blog/2013-05-16-personal-api-tokens/" target="_blank" rel="noopener">Personal API
Tokens</a>。</p>
<p>本文会介绍如何用 Spring Security 来实现。Spring Security 虽然功能强大，但配置起来经常让人云里雾里，所以我们要试图了解一些 Spring Security 的工作原理，再具体实现 API Token 的权限认证。</p>
<a id="more"></a>
<h2 id="spring-security-基本原理"><a class="header-anchor" href="#spring-security-基本原理"></a>Spring Security 基本原理</h2>
<p>Java Servlet 和 Spring Security 都使用了设计模式中的 <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern" target="_blank" rel="noopener">责任链模式
</a>。简单地说，它们都定义了许多过滤器（Filter），每一个请求都会经过层层过滤器的处理，最终返回。如下图：</p>
<img src="/2019/Token-Authentication-via-Spring-Security/filter-chain.svg" class="" title="Spring Security Fitler Chain">
<p>其中，Spring Security 在 Servlet 的过滤链（filter chain）中注册了一个过滤器
<code>FilterChainProxy</code>，它会把请求代理到 Spring Security 自己维护的多个过滤链，每个过滤链会匹配一些 URL，如图中的 <code>/foo/**</code>，如果匹配则执行对应的过滤器。过滤链是有顺序的，一个请求只会执行第一条匹配的过滤链。Spring Security 的配置本质上就是新增、删除、修改过滤器。下图是配置了 <code>http.formLogin()</code> 的过滤链：</p>
<img src="/2019/Token-Authentication-via-Spring-Security/filter-chains.png" class="" title="Actual Filter Chains">
<p>可以看到默认的过滤器里包含了许多内容，如 <code>CsrfFilter</code> 来生成和校验 CSRF Token
，<code>UsernamePasswordAuthenticationFilter</code> 来处理用户名密码的认证，
<code>SessionManagementFilter</code> 来管理 Session 等等。而我们关心的“权限认证”，它其实分为两个部分：</p>
<ol>
<li>认证（Authentication）：即证明“你是你”，常见的如果用户名密码匹配，则认为操作者是该用户。</li>
<li>授权（Authorization）：即判断“你有没有资格”，例如“删贴”功能只允许管理员使用。</li>
</ol>
<h3 id="认证-authentication"><a class="header-anchor" href="#认证-authentication"></a>认证(Authentication)</h3>
<p>以用户名密码的方式为例，要认证一个用户是不是系统的用户，我们需要两个步骤：</p>
<ol>
<li>一个从请求的报文中抽取用户名及密码信息等认证信息。认证信息需要实现 <code>Authentication</code> 接口。</li>
<li>另一个用来验证认证信息是否正确，如密码是否正确、API token 是否正确。</li>
<li>额外地，判断该用户是否有资格访问某个 URL，这个属于授权。</li>
</ol>
<p>验证用户、密码的逻辑一般需要自定义且常常会比较复杂，Spring Security 中的
<code>AuthenticationManager</code> 定义了验证的接口：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationManager</span> </span>&#123;</span><br><span class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果认证通过，返回认证信息（比如擦除密码后的认证信息）</li>
<li>如果认证失败，抛 <code>AuthenticationException</code> 异常。</li>
<li>如果无法决定，返回 null。</li>
</ul>
<p>Spring Security 内部使用最多的实现是 <code>ProviderManager</code>，而它内部又使用了一个认证的链条，包含了多个<code>AuthenticationProvier</code>，<code>ProviderManager</code> 会逐一调用它们直到有一个 provider成功返回。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line">    <span class="function">Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; authentication)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与 <code>AuthenticationManager</code> 不同的是它多了一个 <code>supports</code> 方法用来判断Provider
是否支持当前的认证信息。如一个 API Token 的认证器就不支持用户名密码的认证信息。</p>
<p>另外，ProviderManager 还定义了父子关系，如果当前 ProviderManager 中所有的
Provier 都无法认证某个信息，它就会让父 ProviderManager 来判断。如图：</p>
<img src="/2019/Token-Authentication-via-Spring-Security/provider-manager-hierarchy.svg" class="" title="Provider Manager Hierarchy">
<p>理论上我们不需要理解这些内容，完全可以自己编写一个过滤器来处理所有需求。只是如果使用了这套接口，就能享受 Spring Security 的一些“基础设施”，例如抛
<code>AuthenticationException</code> 时，<code>ExceptionTranslationFilter</code> 会调用配置好的
<code>authenticationEntryPoint.commence()</code> 方法进行处理，返回 401 等等。</p>
<h3 id="授权-authorization"><a class="header-anchor" href="#授权-authorization"></a>授权(Authorization)</h3>
<p>要判断“你有没有资格”，首先要知道关于“你”的信息，也就是前一小节中说的
<code>Authentication</code> 接口；其次需要知道要访问的资源及资源的配置，如要访问 URL，该
URL 能被什么角色访问。类似地，Spring Security 已经定义了相关的接口，授权会在
<code>FilterSecurityInterceptor</code> 中启动。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccessDecisionManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">decide</span><span class="params">(Authentication authentication,</span></span></span><br><span class="line"><span class="function"><span class="params">                Object object,</span></span></span><br><span class="line"><span class="function"><span class="params">                Collection&lt;ConfigAttribute&gt; configAttributes)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> AccessDeniedException, InsufficientAuthenticationException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(ConfigAttribute attribute)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; clazz)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数 <code>decide</code> 会决定授权是否成功，如果权限不足则抛 <code>AccessDeniedException</code> 异常。函数参数说明：</p>
<ul>
<li><code>authentication</code> 代表了“认证信息”，从中可以获得诸如当前用户的角色等信息</li>
<li><code>object</code> 即要访问的资源，如某个 URL 或是某个函数</li>
<li><code>configAttributes</code> 代表该资源的配置，如该 URL 只能被“管理员”角色（<code>ROLE_ADMIN</code>）访问。</li>
</ul>
<p>Spring Security 中，具体的授权策略是“投票机制”，每一个 <code>AccessDecisionVoter</code>
都能投票，而最后如何统计结果，由 <code>AccessDecisionManager</code> 的具体实现决定。如
<code>AffirmativeBased</code> 只需要有人赞成即可；<code>ConsensusBased</code> 需要多数人赞成；
<code>UnanimousBased</code> 需要所有人赞成。默认使用 <code>AffirmativeBased</code>。</p>
<p>同 Authentication 一样，遵循这套逻辑，Spring Security 的默认配置就能减少我们的工作量。例如上面提到的投票机制，还有抛 AccessDeniedException 异常时返回 403 等处理。</p>
<h3 id="配置"><a class="header-anchor" href="#配置"></a>配置</h3>
<p>Spring Security 的运行原理不难理解，但如何达到想要的配置一直是我学习时的痛点。这里也只是简要说明，具体的配置不是三言两语能说清的。下面举一个简单的示例，说明一些对应关系：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ②</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.authenticationProvider(<span class="keyword">new</span> TokenAuthenticationProvider(tokenService));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .antMatcher(<span class="string">"/api/v1/square/**"</span>) <span class="comment">// ③</span></span><br><span class="line">                .addFilterAfter(<span class="keyword">new</span> TokenAuthenticationFilter(), BasicAuthenticationFilter<span class="class">.<span class="keyword">class</span>) // ④</span></span><br><span class="line"><span class="class">                .<span class="title">authorizeRequests</span>()</span></span><br><span class="line">                .anyRequest().hasRole("API"); // ⑤</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>继承 <code>WebSecurityConfigurerAdapter</code> 开始。之前提到 Spring Security 可以包含多条过滤链，每个 <code>WebSecurityConfigurerAdapter</code> 对应一条过滤链。③ 中指定要匹配的 URL 模式，顺序由 <code>@Order</code> 指定。</li>
<li>重载 <code>configure(AuthenticationManagerBuilder auth)</code> 方法来配置认证逻辑，一份 <code>WebSecurityConfigurerAdapter</code> 配置会生成一个 <code>ProviderManager</code>，而这个 <code>configure</code> 方法可以提供多个 <code>AuthenticationProvier</code>。</li>
<li>指定当前过滤链要匹配的 URL 模式。用 <code>antMatcher</code> 指定一个模式，使用
<code>requestMatcher</code> 或 <code>requestMatchers</code> 来进行高级配置，如指定多个模式。</li>
<li>通过 <code>addFilter</code> 相关方法可以在当前过滤链中添加过滤器，但似乎没有删除的方法。</li>
<li><code>hasRole</code> 等用来指定“授权”的逻辑，比如该行表示访问所有的 URL 都需要 <code>API</code>
角色。</li>
</ol>
<h2 id="api-token-实现"><a class="header-anchor" href="#api-token-实现"></a>API Token 实现</h2>
<p>要实现开头说的 API Token 的权限认证，我们需要下面几样东西：</p>
<ol>
<li>一个 <code>Authentication</code> 的实现，用于存放 token 相关的认证信息。</li>
<li>一个过滤器，抽取请求中的 token 信息</li>
<li>一个 <code>AuthenticationProvier</code> 用来确认 token 认证信息是否正确。</li>
<li>当认证失败时，我们想返回自定义的错误信息，因此需要一个过滤器。</li>
</ol>
<h3 id="认证信息"><a class="header-anchor" href="#认证信息"></a>认证信息</h3>
<p>由于 API token 只需要存放 token 本身即可，所以实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthentication</span> <span class="keyword">implements</span> <span class="title">Authentication</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String token;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TokenAuthentication</span><span class="params">(String token)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.token = token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getCredentials</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> token;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ... 省略其它方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="抽取-token-的过滤器"><a class="header-anchor" href="#抽取-token-的过滤器"></a>抽取 token 的过滤器</h3>
<p>因为 token 信息是在 URL 中指定的，所以这个过滤器会读取 URL 中的 parameter 并生成上节定义的 <code>TokenAuthentication</code>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthenticationFilter</span> <span class="keyword">extends</span> <span class="title">OncePerRequestFilter</span> </span>&#123; <span class="comment">// ①</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest req, HttpServletResponse res, FilterChain fc)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        SecurityContext context = SecurityContextHolder.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context.getAuthentication() != <span class="keyword">null</span> &amp;&amp; context.getAuthentication().isAuthenticated()) &#123;</span><br><span class="line">            <span class="comment">// do nothing</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// ②</span></span><br><span class="line">            Map&lt;String, String[]&gt; params = req.getParameterMap();</span><br><span class="line">            <span class="keyword">if</span> (!params.isEmpty() &amp;&amp; params.containsKey(<span class="string">"token"</span>)) &#123;</span><br><span class="line">                String token = params.get(<span class="string">"token"</span>)[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (token != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Authentication auth = <span class="keyword">new</span> TokenAuthentication(token);</span><br><span class="line">                    SecurityContextHolder.getContext().setAuthentication(auth);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            req.setAttribute(<span class="string">"me.lotabout.springsecurityexample.security.TokenAuthenticationFilter.FILTERED"</span>, <span class="keyword">true</span>); <span class="comment">//③</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fc.doFilter(req, res); <span class="comment">//④</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>① 中继承自 <code>OncePerRequestFilter</code> 没有特别用意，它的功能是能防止这个过滤器被调用多次</li>
<li>② 处获取 URL 中的 token 并把生成的 Authentication 存放在 SecurityContext 里，供后续逻辑使用</li>
<li>③ 中设置过 attribute 后，该过滤器不会被再被调用</li>
<li>④ 中执行后面的过滤器</li>
</ul>
<h3 id="校验逻辑"><a class="header-anchor" href="#校验逻辑"></a>校验逻辑</h3>
<p>上面会 URL 中获得 Token，我们需要与数据库中的 token 比较看是否一致，这里就用内存中的比较代替：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenAuthenticationProvider</span> <span class="keyword">implements</span> <span class="title">AuthenticationProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">authenticate</span><span class="params">(Authentication authentication)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (authentication.isAuthenticated()) &#123;</span><br><span class="line">            <span class="keyword">return</span> authentication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从 TokenAuthentication 中获取 token</span></span><br><span class="line">        String token = authentication.getCredentials().toString();</span><br><span class="line">        <span class="keyword">if</span> (Strings.isNullOrEmpty(token)) &#123;</span><br><span class="line">            <span class="keyword">return</span> authentication;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!token.equals(<span class="string">"abcdefg"</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ResultException.of(MyError.TOKEN_NOT_FOUND).errorData(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        User user = User.builder()</span><br><span class="line">                    .username(<span class="string">"api"</span>)</span><br><span class="line">                    .password(<span class="string">""</span>)</span><br><span class="line">                    .authorities(Role.API)</span><br><span class="line">                    .build();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 返回新的认证信息，带上 token 和反查出的用户信息</span></span><br><span class="line">        Authentication auth = <span class="keyword">new</span> PreAuthenticatedAuthenticationToken(user, token, user.getAuthorities());</span><br><span class="line">        auth.setAuthenticated(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> auth;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Class&lt;?&gt; aClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (TokenAuthenticationFilter.TokenAuthentication<span class="class">.<span class="keyword">class</span>.<span class="title">isAssignableFrom</span>(<span class="title">aClass</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="错误处理"><a class="header-anchor" href="#错误处理"></a>错误处理</h3>
<p>我们希望在错误时，返回 200 状态码，同时 body 中包含 <code>&quot;success&quot;: false</code>及具体的错误信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultExceptionTranslationFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain fc)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fc.doFilter(request, response);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ResultException ex) &#123;</span><br><span class="line">            response.setContentType(<span class="string">"application/json; charset=UTF-8"</span>);</span><br><span class="line">            response.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br><span class="line">            response.getWriter().println(JsonUtil.toJson(Response.of(ex)));</span><br><span class="line">            response.getWriter().flush();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="组装配置"><a class="header-anchor" href="#组装配置"></a>组装配置</h3>
<p>具体的配置和上面提到的差不多，注意到我们还关闭了 CSRF 和 Session。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PredictorSecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        auth.authenticationProvider(<span class="keyword">new</span> TokenAuthenticationProvider(tokenService));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        http</span><br><span class="line">                .antMatcher(PATTERN_SQUARE)</span><br><span class="line">                .addFilterAfter(<span class="keyword">new</span> TokenAuthenticationFilter(), BasicAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">addFilterAfter</span>(<span class="title">new</span> <span class="title">ResultExceptionTranslationFilter</span>(), <span class="title">ExceptionTranslationFilter</span>.<span class="title">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">authorizeRequests</span>()</span></span><br><span class="line">                .anyRequest().hasRole("API")</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .sessionManagement()</span><br><span class="line">                .sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整的代码可以在 <a href="https://github.com/lotabout/spring-security-example" target="_blank" rel="noopener">Spring Security Example</a> 找到。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>每次用 Spring Security 都是现搜现用，如果示例不工作时往往不知道如何处理，所以这些更深入地学习了原理并做了笔记，希望各位看官用得上。</p>
<ul>
<li>Spring Security 会注册 FilterChainProxy，自身包含多个 Filter Chain</li>
<li>认证 Authentication 与授权 Authorization 是分开的两套逻辑</li>
<li><code>AuthenticationManager</code> 包含多个 <code>AuthenticationProvider</code> 且可以有父节点</li>
<li>授权的入口是 <code>AccessDecisionManager</code>，它的几个实现类代表着不同的投票方法。</li>
<li>每个继承 <code>WebSecurityConfigurerAdapter</code> 的类定义一条新的 Filter Chain</li>
</ul>
<p>最后我们用了上面的知识实现了基于 API token 的认证，授权仍旧用的 Spring
Security 默认的机制。</p>
<h2 id="参考"><a class="header-anchor" href="#参考"></a>参考</h2>
<ul>
<li><a href="https://spring.io/guides/topicals/spring-security-architecture/" target="_blank" rel="noopener">https://spring.io/guides/topicals/spring-security-architecture/</a> Spring
Security 官方架构文档，本文的知识很多来源于此</li>
<li><a href="http://www.spring4all.com/article/439" target="_blank" rel="noopener">Spring Security源码分析一：Spring Security认证过程</a> 详细认证过程分析，对于理解认证链路很有帮助。</li>
<li><a href="http://www.spring4all.com/article/458" target="_blank" rel="noopener">Spring Security源码分析二：Spring Security授权过程</a></li>
</ul></div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'lotaboutlife';
var disqus_identifier = '2019/Token-Authentication-via-Spring-Security/';
var disqus_title = 'Spring Security 实现 API Token 权限认证';
var disqus_url = 'https://lotabout.me/2019/Token-Authentication-via-Spring-Security/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>