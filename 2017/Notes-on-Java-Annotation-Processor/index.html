<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="最近基于工作上的需求调研了下 Java Annotation Processor 的使用方式，开篇博客记录下学习过程中遇到的坑。可以由于平时用到 Annotation 的场景特别少，因此能搜索到的教程特别有限，也希望文章在某种程度上填补部分空白吧。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Java Annotation Processor 小记 | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/annotation/" rel="tag">annotation</a><a class="post-tag-link" href="/tags/java/" rel="tag">java</a></div><div class="post-time">2017-12-31</div></div></div><div class="container post-header"><h1>Java Annotation Processor 小记</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#认识-java-annotation"><span class="toc-number">1.</span> <span class="toc-text">认识 Java Annotation</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#项目搭建"><span class="toc-number">2.</span> <span class="toc-text">项目搭建</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#目录结构也不知道谁规定的-看到的目标一般都是分两个子模块-一个是-annotation-存放"><span class="toc-number">2.1.</span> <span class="toc-text">目录结构也不知道谁规定的，看到的目标一般都是分两个子模块，一个是 annotation 存放</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pom-注意点"><span class="toc-number">2.2.</span> <span class="toc-text">pom 注意点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件内容"><span class="toc-number">2.3.</span> <span class="toc-text">文件内容</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#model-api"><span class="toc-number">3.</span> <span class="toc-text">Model API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#从-typeelement-中获取所有字段或方法"><span class="toc-number">3.1.</span> <span class="toc-text">从 TypeElement 中获取所有字段或方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取字段的类型"><span class="toc-number">3.2.</span> <span class="toc-text">获取字段的类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取注解中的类"><span class="toc-number">3.3.</span> <span class="toc-text">获取注解中的类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#代码生成"><span class="toc-number">4.</span> <span class="toc-text">代码生成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#模板引擎"><span class="toc-number">4.1.</span> <span class="toc-text">模板引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#javapoet"><span class="toc-number">4.2.</span> <span class="toc-text">JavaPoet</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#写在最后"><span class="toc-number">5.</span> <span class="toc-text">写在最后</span></a></li></ol></details></div><div class="container post-content"><p>最近基于工作上的需求调研了下 Java Annotation Processor 的使用方式，开篇博客记录下学习过程中遇到的坑。可以由于平时用到 Annotation 的场景特别少，因此能搜索到的教程特别有限，也希望文章在某种程度上填补部分空白吧。</p>
<h2 id="认识-java-annotation"><a class="header-anchor" href="#认识-java-annotation"></a>认识 Java Annotation</h2>
<p>Java 里的 Annotation （注解）相信大家都不陌生，从内置的 <code>@Override</code> 到 junit
里的 <code>@Test</code> ，再到 lombok 里的 <code>@Getter</code>, <code>@Setter</code> 都是大家常用的注解。之所以叫作“注解”，是因为它就像是我们对代码加上的一种“注解”一般。一般注解可以出现在类、方法、变量、参数及包名上。在编译期或运行时，我们就能找到并使用这些“注解”，并做一些操作。</p>
<p>这里我以实际的需求为例，代码可以在 Github 上找到：<a href="https://github.com/lotabout/transformer-playground" target="_blank" rel="noopener">transformer-playground</a>。</p>
<p>在开发中，我们会重复一些代码，例如写一份领域模型 BO (business object)，包括了模型的属性及方法 (OOP)。由于这个模型的信息可能需要发送给其它的领域，而又希望领域模型和具体的表示能隔离，因此常常会创建一份 POJO(Plain Old Java Object)，它的字段和 BO 几乎一致。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicantBo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;EducationVo&gt; educationList;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// don't want to go public</span></span><br><span class="line">    <span class="keyword">private</span> ZonedDateTime lastUpdate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// business logic here</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicantPojo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> List&lt;EducationPojo&gt; educationList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此经常需要写一些转换代码，把 BO 转成 Pojo 或者反过来。这时候想起 Java
的注解是能实现代码的自动生成的，于是希望能像下面这样的方式来写代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Transformer</span>(to = ApplicantPojo<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">ApplicantBo</span> </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>期待加了这个注解之后，能自动生成一些代码，而不用自己写转换类。这里要说明两个内容：</p>
<ol>
<li>一般的 Annotation Processor 能生成新的类，但不能修改现有的类。像 lombok 这种能为类生成新方法的工具其实是直接修改 byte code 实现的。</li>
<li>Annotation Processor 的一大好处是如果原始的代码发生变化，可以防止自己忘记修改一些对应的类。如 lombok 的 <code>@Getter</code> 可以防止新加字段后忘记加相应的
Getter，而上面说的 <code>@Transformer</code> 更可以防止忘记为新字段添加转换逻辑。</li>
</ol>
<p>当然，Annotation 的好处还有很多，总的来说，Annotation 赋予了我们更强的表达能力，使我们代码最更少，模块化更高，理解更容易（总得吹一波）。</p>
<h2 id="项目搭建"><a class="header-anchor" href="#项目搭建"></a>项目搭建</h2>
<p>关于 Annotation Processor ，网上已经有相当好的入门教程了，这里我推荐两个：</p>
<ol>
<li><a href="https://academy.realm.io/posts/360andev-ryan-harter-eliminate-boilerplate/" target="_blank" rel="noopener">@Eliminate(“Boilerplate”)</a></li>
<li><a href="http://hannesdorfmann.com/annotation-processing/annotationprocessing101" target="_blank" rel="noopener">ANNOTATION PROCESSING 101</a></li>
</ol>
<p>第一个是演讲，基本上能对 Annotation Processor 的基本工作原理能有大概的理解，第二篇则是一个很详细的具体示例。这里我会为自己简要记录下要点。</p>
<h3 id="目录结构也不知道谁规定的-看到的目标一般都是分两个子模块-一个是-annotation-存放"><a class="header-anchor" href="#目录结构也不知道谁规定的-看到的目标一般都是分两个子模块-一个是-annotation-存放"></a>目录结构也不知道谁规定的，看到的目标一般都是分两个子模块，一个是 <code>annotation</code> 存放</h3>
<p>annotation 的定义，另一个是 <code>processor</code>，存放具体生成代码的逻辑。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.</span><br><span class="line">├── pom.xml</span><br><span class="line">├── transformer-annotations</span><br><span class="line">│   ├── pom.xml</span><br><span class="line">│   └── src&#x2F;main&#x2F;java</span><br><span class="line">│               └── me.lotabout.annotation</span><br><span class="line">│                   └── Transformer.java</span><br><span class="line">└── transformer-processors</span><br><span class="line">    ├── pom.xml</span><br><span class="line">    └── src&#x2F;main</span><br><span class="line">            ├── java</span><br><span class="line">            │   └── me.lotabout.processor</span><br><span class="line">            │       └── TransformerProcessor.java</span><br><span class="line">            └── resources</span><br><span class="line">                └── META-INF</span><br><span class="line">                    └── services</span><br><span class="line">                        └── javax.annotation.processing.Processor</span><br></pre></td></tr></table></figure>
<p>其中， <code>javax.annotation.processing.Processor</code> 这个文件的文件名是固定的，我们需要把我们实现了的 Processor （本例中 <code>TransformerProcessor</code>）写到文件里，这样则 javac 在编译过程中才能找到对应的 Processor。文件里每行写一个 Processor 的全限定名。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat javax.annotation.processing.Processor</span><br><span class="line">me.lotabout.processor.TransformerProcessor</span><br></pre></td></tr></table></figure>
<h3 id="pom-注意点"><a class="header-anchor" href="#pom-注意点"></a>pom 注意点</h3>
<p>正常情况下，如果完成了项目的搭建，编译后会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[ERROR] Failed to execute goal org.apache.maven.plugins:maven-compiler-plugin:3.1:compile (default-compile) on project transformer-processors: Compilation failure</span><br><span class="line">[ERROR] Bad service configuration file, or exception thrown while constructing Processor object: javax.annotation.processing.Processor: Provider me.lotabout.processor.TransformerProcessor not found</span><br><span class="line">[ERROR] -&gt; [Help 1]</span><br></pre></td></tr></table></figure>
<p>这是因为 javac 在编译时，会用 <code>javax.annotation.processing.Processor</code> 里指定的类去处理源代码，因此 javac 预期在 classpath 里能找到一个编译好的 processor，但这显然是不可能的。要解决这个问题，我们需要显示告诉 javac 为当前项目忽略
annotation processing。如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">source</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">target</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">compilerArgument</span>&gt;</span>-proc:none<span class="tag">&lt;/<span class="name">compilerArgument</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意 <code>-proc:none</code>。参考 <a href="https://stackoverflow.com/questions/36248959/bad-service-configuration-file-or-exception-thrown-while-constructing-processor" target="_blank" rel="noopener">StackOverflow</a>。</p>
<h3 id="文件内容"><a class="header-anchor" href="#文件内容"></a>文件内容</h3>
<p>定义新的注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transformer &#123;</span><br><span class="line">    Class&lt;?&gt;[] from() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] to() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>用 <code>@interface</code> 定义注解</li>
<li><code>@Target()</code> 来指定注解允许出现的位置，这里指定 <code>ElementType.TYPE</code> 限制能出现在类型定义上，如 interface, class 上。</li>
<li><code>@Retention</code> 用于指定注解的保留情况，如 <code>RetentionPolicy.SOURCE</code> 代表这个注解是源代码级别的，编译之后生成 byte code 时注解就会被移除。有一些注解是可以保留到运行时的。</li>
</ol>
<p>Annotation Processor 的定义：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransformerProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SourceVersion <span class="title">getSupportedSourceVersion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (SourceVersion.latest().compareTo(SourceVersion.RELEASE_8) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> SourceVersion.latest();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> SourceVersion.RELEASE_8;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ImmutableSet.of(Transformer<span class="class">.<span class="keyword">class</span>.<span class="title">getCanonicalName</span>())</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这三件套是必须的：</p>
<ol>
<li><code>getSupportedSourceVersion</code> 返回支持的版本</li>
<li><code>getSupportedAnnotationTypes</code> 返回该 Processor 支持的所有注解。换句话说，这里返回的内容将作为 <code>process</code> 函数的第一个参数返回。</li>
<li><code>process</code> 函数，在这里写代码生成的逻辑。</li>
</ol>
<p>最后注意到 <code>extends AbstractProcessor</code>，嗯，这么做就对了。</p>
<h2 id="model-api"><a class="header-anchor" href="#model-api"></a>Model API</h2>
<p>最头疼的莫过于 <code>java.lang.model</code> 的相关 API 了，完全找不到全面的文档。这里记录几个用到的：</p>
<h3 id="从-typeelement-中获取所有字段或方法"><a class="header-anchor" href="#从-typeelement-中获取所有字段或方法"></a>从 TypeElement 中获取所有字段或方法</h3>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;VariableElement&gt; <span class="title">getAllFields</span><span class="params">(TypeElement type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ElementFilter.fieldsIn(type.getEnclosedElements())</span><br><span class="line">            .stream()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;MethodEntry&gt; <span class="title">getAllMethods</span><span class="params">(TypeElement type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ElementFilter.methodsIn(type.getEnclosedElements())</span><br><span class="line">            .stream()</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="获取字段的类型"><a class="header-anchor" href="#获取字段的类型"></a>获取字段的类型</h3>
<p><code>VariableElement</code> 用来表示一个字段，那么如何获取字段的类型呢？</p>
<p>一个字段的类型可能是基本类型如 <code>int</code>, <code>boolean</code> 之类的，也可能是类如
<code>String</code>，还可能包括一 些泛型的类如 <code>List&lt;String&gt;</code>。而 <code>TypeElement</code> 保存的是类型本身的信息，例如，如是一个 <code>TypeElement</code> 表示 <code>List&lt;String&gt;</code>，它其实保存的是 <code>List&lt;T&gt;</code> 的信息，没有办法获取 <code>String</code> 这个具体类型的。</p>
<p>其实 Java 是用 <code>TypeMirror</code> 来代表一个具体类型的：</p>
<ol>
<li><code>variable.asType()</code> 可以获得 <code>variable</code> 的具体类型。</li>
<li><code>typeMirror.getKind()</code> 可以获知类型的信息，如 <code>int</code> 则是 <code>TypeKind.INT</code>，而所有的类者属于 <code>TypeKind.DECLARED</code>。</li>
<li><code>(TypeElement)((DeclaredType)typeMirror).asElement()</code> 可以将 TypeMirror 转换为 <code>TypeElement</code>。但如果不是 <code>DECLARED</code> 类型则会出异常。</li>
<li>如果是泛型，可以通过 <code>((DeclaredType)typeMirror).getTypeArguments()</code> 来得到具体的类型信息。如 <code>List&lt;String&gt;</code> 可以得到 <code>String</code>。</li>
<li>如果是数组类型，想得到具体的类型信息，如 <code>String[]</code> 想得到 <code>String</code>，则需要通过 <code>((ArrayType)typeMirror).getComponentType()</code> 来获取。</li>
</ol>
<h3 id="获取注解中的类"><a class="header-anchor" href="#获取注解中的类"></a>获取注解中的类</h3>
<p>例如我们定义的 Transformer 类，它的参数都是 <code>Class[]</code> 类型的。但在编译期间，我们是得不到 <code>Class</code> 信息的，因为这个时候还只有关于源代码的信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Transformer &#123;</span><br><span class="line">    Class&lt;?&gt;[] from() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">    Class&lt;?&gt;[] to() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，正常情况下我们可能想通过下面的操作来得到 <code>from</code> 的类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Element e : roundEnv.getElementsAnnotatedWith(Transformer<span class="class">.<span class="keyword">class</span>)) </span>&#123;</span><br><span class="line">        Transformer transformer = e.getAnnotation(Transformer<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        Class[] from = transformer.from();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但会有如下错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">javax.lang.model.type.MirroredTypeException: Attempt to access Class object for TypeMirror java.lang.Runnable</span><br></pre></td></tr></table></figure>
<p>所以我们只能曲线救国：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;AnnotationMirror&gt; <span class="title">getAnnotationMirror</span><span class="params">(TypeElement element, Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    String clazzName = clazz.getName();</span><br><span class="line">    <span class="keyword">for</span>(AnnotationMirror m : element.getAnnotationMirrors()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(m.getAnnotationType().toString().equals(clazzName)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(m);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;AnnotationValue&gt; <span class="title">getAnnotationValue</span><span class="params">(AnnotationMirror annotationMirror, String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(Map.Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; entry : annotationMirror.getElementValues().entrySet() ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(entry.getKey().getSimpleName().toString().equals(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> Optional.ofNullable(entry.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Optional.empty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;TypeMirror&gt; <span class="title">getTransformerClasses</span><span class="params">(TypeElement clazz, String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getAnnotationMirror(clazz, Transformer<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">flatMap</span>(<span class="title">annotation</span> -&gt; <span class="title">TypeEntry</span>.<span class="title">getAnnotationValue</span>(<span class="title">annotation</span>, <span class="title">key</span>))</span></span><br><span class="line">            // ^ note that annotation value here corresponds to Class[],</span><br><span class="line">            .map(annotation -&gt; (List&lt;AnnotationValue&gt;)annotation.getValue())</span><br><span class="line">            .map(fromClasses -&gt; fromClasses.stream()</span><br><span class="line">                    .map(fromClass -&gt; (TypeMirror)fromClass.getValue())</span><br><span class="line">                    .collect(Collectors.toList()))</span><br><span class="line">            .orElse(ImmutableList.of());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个问题在 <a href="https://area-51.blog/2009/02/13/getting-class-values-from-annotations-in-an-annotationprocessor/" target="_blank" rel="noopener">这篇文章</a> 中有很详细的描述。</p>
<h2 id="代码生成"><a class="header-anchor" href="#代码生成"></a>代码生成</h2>
<p>最后一个内容是代码生成，其实 Annotation Processor 最后是生成 Java 代码，这意味着不论采用任何形式，最终只要把一些字符（Java 源码）写入到一个文件就可以了。实际中有两种方式，各有优缺点。</p>
<h3 id="模板引擎"><a class="header-anchor" href="#模板引擎"></a>模板引擎</h3>
<p>如 <a href="http://velocity.apache.org/" target="_blank" rel="noopener">velocity</a> 或
<a href="https://mustache.github.io/" target="_blank" rel="noopener">Mustache</a>。其中 velocity 也是 Intellij 的代码生成功能使用的模板引擎。</p>
<p>使用模板引擎的好处是代码的结构比较可控，看模板就能大概看出生成的代码长什么样。但一个重要缺点是需要自己导入代码中用到的包，而在 Java 文件中，导入包和实际的代码是在两个区域，这对于生成代码来说很不方面（要是用到了就会有同感了）。另一个小总是是空格处理麻烦，为了保证输出的源代码格式好看，通常需要小心处理模板中的空格（velocity），导致模板很乱。</p>
<h3 id="javapoet"><a class="header-anchor" href="#javapoet"></a>JavaPoet</h3>
<p><a href="https://github.com/square/javapoet" target="_blank" rel="noopener">JavaPoet</a> 是各大教程中都提到的 Java 代码生成库，它对常用的 Java 概念（如类，方法，变量等）做了建模，因此我们就能像写代码一样一部分一部分生成 Java 代码。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">MethodSpec main = MethodSpec.methodBuilder(<span class="string">"main"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.STATIC)</span><br><span class="line">    .returns(<span class="keyword">void</span><span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">    .addParameter(String[].class, "args")</span><br><span class="line">    .addStatement("$T.out.println($S)", System.class, "Hello, JavaPoet!")</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">TypeSpec helloWorld = TypeSpec.classBuilder(<span class="string">"HelloWorld"</span>)</span><br><span class="line">    .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">    .addMethod(main)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">JavaFile javaFile = JavaFile.builder(<span class="string">"com.example.helloworld"</span>, helloWorld)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">javaFile.writeTo(System.out);</span><br></pre></td></tr></table></figure>
<p>会生成下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.example.helloworld;</span><br><span class="line"></span><br><span class="line">public final class HelloWorld &#123;</span><br><span class="line">  public static void main(String[] args) &#123;</span><br><span class="line">    System.out.println(&quot;Hello, JavaPoet!&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我认为它的主要好处就是自动 import，其它我真不觉得有什么超过模板引擎的地方。但自动 import 这个功能就足以让我在写 <code>@Transformer</code> 的时候使用它而不是 velocity。</p>
<p>另外注意要使用它的自动 import 功能，需要我们在生成代码时使用 <code>addStatement</code> 并使用 <code>$T</code> 语法来提供类型信息，否则是它是没办法识别文本中的包的。</p>
<h2 id="写在最后"><a class="header-anchor" href="#写在最后"></a>写在最后</h2>
<p>我个人的背景是 C + Lisp 开始的，所以对于元编程(meta-programming) 是有一定执着的，想比于 Lisp，Java 的 Annotation Processor 实在是太蹩脚了。但与此同时，不得不说 Java 的源码结构比 Lisp 的无限括号还是更方便阅读的，并且我自己也很喜欢
Annotation 这样的“无入侵”的编程风格的。</p>
<p>另外元编程也许有点“屠龙之术”吧，不过如果现实中真的有“龙”出现的时候，不要犹豫，祭出“屠龙宝刀”吧！</p></div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'lotaboutlife';
var disqus_identifier = '2017/Notes-on-Java-Annotation-Processor/';
var disqus_title = 'Java Annotation Processor 小记';
var disqus_url = 'https://lotabout.me/2017/Notes-on-Java-Annotation-Processor/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>