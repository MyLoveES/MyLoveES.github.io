<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>Python Decorator(装饰器) | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/decorator/" rel="tag">decorator</a><a class="post-tag-link" href="/tags/python/" rel="tag">python</a></div><div class="post-time">2017-09-29</div></div></div><div class="container post-header"><h1>Python Decorator(装饰器)</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#手写装饰器"><span class="toc-number">1.</span> <span class="toc-text">手写装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#语法糖"><span class="toc-number">2.</span> <span class="toc-text">@ 语法糖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#带参数的装饰器"><span class="toc-number">3.</span> <span class="toc-text">带参数的装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#我是谁？"><span class="toc-number">4.</span> <span class="toc-text">我是谁？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类作为装饰器"><span class="toc-number">5.</span> <span class="toc-text">类作为装饰器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">6.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#扩展阅读"><span class="toc-number">7.</span> <span class="toc-text">扩展阅读</span></a></li></ol></details></div><div class="container post-content"><p>今天来说说 Python 里的装饰器 (decorator)。它不难，但却几乎是 “精通” Python 的路上的第一道关卡。让我们来看看它到底是什么东西，为什么我们需要它。</p>
<h2 id="手写装饰器"><a class="header-anchor" href="#手写装饰器"></a>手写装饰器</h2>
<p>现在我们要写一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>然后我们想看看运行的结果，于是写了几个 print 语句：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">print(<span class="string">"add('a', 'b')"</span>, add(<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results:</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># add('a', 'b') ab</span></span><br></pre></td></tr></table></figure>
<p>现在我们想看看测试这个函数的性能，于是我们加上这个代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">after = time()</span><br><span class="line">print(<span class="string">"time taken: &#123;&#125;"</span>.format(after - before))</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">after = time()</span><br><span class="line">print(<span class="string">"time taken: &#123;&#125;"</span>.format(after - before))</span><br><span class="line"></span><br><span class="line">before = time()</span><br><span class="line">print(<span class="string">"add('a', 'b')"</span>, add(<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line">after = time()</span><br><span class="line">print(<span class="string">"time taken: &#123;&#125;"</span>.format(after - before))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># time taken: 0.00017189979553222656</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># time taken: 9.751319885253906e-05</span></span><br><span class="line"><span class="comment"># add('a', 'b') ab</span></span><br><span class="line"><span class="comment"># time taken: 0.00012969970703125</span></span><br></pre></td></tr></table></figure>
<p>代码马上变得很复杂。但最重要的是，我们得写一堆代码（复制粘贴），程序员是懒惰的，所以我们就想到一些更简单的方法，与其写这么多次，我们可以只写一次代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    before = time()</span><br><span class="line">    result = x + y</span><br><span class="line">    after = time()</span><br><span class="line">    print(<span class="string">'elapsed: '</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br><span class="line">print(<span class="string">"add('a', 'b')"</span>, add(<span class="string">'a'</span>, <span class="string">'b'</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Results</span></span><br><span class="line"><span class="comment"># elapsed:  1.9073486328125e-06</span></span><br><span class="line"><span class="comment"># add(10) 20</span></span><br><span class="line"><span class="comment"># elapsed:  9.5367431640625e-07</span></span><br><span class="line"><span class="comment"># add(20, 30) 50</span></span><br><span class="line"><span class="comment"># elapsed:  1.9073486328125e-06</span></span><br><span class="line"><span class="comment"># add('a', 'b') ab</span></span><br></pre></td></tr></table></figure>
<p>不论是代码的修改量还是代码的美观程度，都比之前的版本要好！</p>
<p>但是，现在我们写了另一个函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br></pre></td></tr></table></figure>
<p>我们必须再为 <code>sub</code> 函数加上和 <code>add</code> 相同的性能测试代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    before = time()</span><br><span class="line">    result = x - y</span><br><span class="line">    after = time()</span><br><span class="line">    print(<span class="string">'elapsed: '</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure>
<p>作为一个懒惰的程序员，我们立马就发现了，有一个 “模式” 反复出现，即执行一个函数，并计算这个函数的执行时间。于是我们就可以把这个模式抽象出来，用函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    before = time()</span><br><span class="line">    result = func(x, y)</span><br><span class="line">    after = time()</span><br><span class="line">    print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line"></span><br><span class="line">print(<span class="string">"add(10)"</span>, timer(add, <span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>, timer(add, <span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p>但这样还是很麻烦，因为我们得改到所有的测试用例，把 <code>add(20, 30)</code> 改成
<code>timer(add, 20, 30)</code>。于是我们进一步改进，让 timer 返回函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = func(x, y)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add = timer(add)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">sub = timer(sub)</span><br><span class="line"></span><br><span class="line">print(<span class="string">"add(10)"</span>,       add(<span class="number">10</span>))</span><br><span class="line">print(<span class="string">"add(20, 30)"</span>,   add(<span class="number">20</span>, <span class="number">30</span>))</span><br></pre></td></tr></table></figure>
<p>这里的最后一个问题是，我们的 timer 包装的函数可能有不同的参数，于是我们可以进一步用 <code>*args, **kwargs</code> 来传递参数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br></pre></td></tr></table></figure>
<p>这里的 <code>timer</code> 函数就是一个 “装饰器”，它接受一个函数，并返回一个新的函数。在装饰器的内部，对原函数进行了“包装”。</p>
<p>注：上面的例子取自 <a href="https://youtu.be/7lmCu8wz8ro?t=45m25s" target="_blank" rel="noopener">What Does it Take to Be an Expert At Python</a>。</p>
<h2 id="语法糖"><a class="header-anchor" href="#语法糖"></a>@ 语法糖</h2>
<p>上一节是一个懒惰的程序员用原生的 Python 写的装饰器，但在装饰器的使用上，用的是这个代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add = timer(add)        <span class="comment"># &lt;- notice this</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sub</span><span class="params">(x, y = <span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x - y</span><br><span class="line">sub = timer(sub)</span><br></pre></td></tr></table></figure>
<p>上面这个语句里，我们把 <code>add</code> 的名字重复了 3 次，如果函数改了名字，我们就得改 3
处。懒惰的程序员就想了一个更“好”的方法，提供了一个语法来替换上面的内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>这就是我们最常见的装饰器的形式了，这两种写法完全等价，只是 <code>@</code> 写法更简洁一些。</p>
<h2 id="带参数的装饰器"><a class="header-anchor" href="#带参数的装饰器"></a>带参数的装饰器</h2>
<p>我们知道下面两种代码是等价的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func = dec(func)</span><br></pre></td></tr></table></figure>
<p>我们可以把它当成是纯文本的替换，于是可以是这样的：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="meta">@dec(arg)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(...)</span>:</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">func = dec(arg)(func)</span><br></pre></td></tr></table></figure>
<p>这也就是我们看到的“带参数”的装饰器。可见，只要 <code>dec(arg)</code> 的返回值满足 “装饰器” 的定义即可。（接受一个函数，并返回一个新的函数）</p>
<p>这里举一个例子（<a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">来源</a>）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">use_logging</span><span class="params">(level)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> level == <span class="string">"warn"</span>:</span><br><span class="line">                logging.warn(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">elif</span> level == <span class="string">"info"</span>:</span><br><span class="line">                logging.info(<span class="string">"%s is running"</span> % func.__name__)</span><br><span class="line">            <span class="keyword">return</span> func(*args)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@use_logging(level="warn")</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(name=<span class="string">'foo'</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"i am %s"</span> % name)</span><br></pre></td></tr></table></figure>
<p>先不管 <code>use_logging</code> 长什么样，先关心它的返回值 <code>decorator</code>，看到 <code>decorator</code>
本身是一个函数，并且参数是函数，返回值是函数，于是确认 <code>decorator</code> 是一个 “装饰器”。于是上面这种“带参数的装饰器”的作用也就很直接了。</p>
<h2 id="我是谁？"><a class="header-anchor" href="#我是谁？"></a>我是谁？</h2>
<p>上面介绍的方法让我们能正确地写出一个装饰器，但是实际使用时还有一个问题：函数信息的丢失：我们可以通过 <code>.__name__</code> 来查看函数的名称，用 <code>help(func)</code> 来查看
<code>func</code> 的 docstring：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add.__name__</span><br><span class="line">wrapper</span><br><span class="line">&gt;&gt;&gt; help(add)</span><br><span class="line">Help on function wraper in module __main__:</span><br><span class="line"></span><br><span class="line">wraper(*args, **kwargs)</span><br></pre></td></tr></table></figure>
<p>可以看到被装饰的函数，名称变成了装饰器返回的函数名 <code>wraper</code>，这对于函数的使用者来说很不方便。于是我们需要修改装饰器，保留原函数的名称：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    wraper.__name__ = func.__name__  <span class="comment"># &lt;- 保留原函数信息</span></span><br><span class="line">    wraper.__doc__ = func.__doc__    <span class="comment"># &lt;- 保留原函数信息</span></span><br><span class="line">    <span class="keyword">return</span> wraper</span><br><span class="line"></span><br><span class="line"><span class="meta">@timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Add two numbers"""</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>此时再查看函数的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; add.__name__</span><br><span class="line">add</span><br><span class="line">&gt;&gt;&gt; help(add)</span><br><span class="line">Help on function add in module __main__:</span><br><span class="line"></span><br><span class="line">add(*args, **kwargs)</span><br><span class="line">    Add two numbers</span><br></pre></td></tr></table></figure>
<p>当然，函数的信息除了 <code>__name__</code> 与 <code>__doc__</code> 外，还有 <code>__module__</code>,
<code>__qualname__</code> 等，每次都手写很浪费时间。Python 提供了内置的装饰器 <code>wraps</code> 来装饰返回的函数：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func) # &lt;- 用于保留原函数信息</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wraper</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    <span class="keyword">return</span> wraper</span><br></pre></td></tr></table></figure>
<p>这样一个完整的装饰器就新鲜出炉了。</p>
<h2 id="类作为装饰器"><a class="header-anchor" href="#类作为装饰器"></a>类作为装饰器</h2>
<p>如果说 Python 里一切都是对象的话，那函数怎么表示成对象呢？其实只需要一个类实现
<code>__call__</code> 方法即可。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></span><br><span class="line">        self._func = func</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args, **kwargs)</span>:</span></span><br><span class="line">        before = time()</span><br><span class="line">        result = self._func(*args, **kwargs)</span><br><span class="line">        after = time()</span><br><span class="line">        print(<span class="string">"elapsed: "</span>, after - before)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="meta">@Timer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x, y=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="string">"""Add two numbers"""</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br></pre></td></tr></table></figure>
<p>也就是说把类的构造函数当成了一个装饰器，它接受一个函数作为参数，并返回了一个对象，而由于对象实现了 <code>__call__</code> 方法，因此返回的对象相当于返回了一个函数。因此该类的构造函数就是一个装饰器。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>装饰器中还有一些其它的话题，例如装饰器中元信息的丢失，如何在类及类的方法上使用装饰器等。但本文里我们主要目的是简单介绍装饰器的原因及一般的使用方法，能用上的地方就大胆地用上吧！</p>
<h2 id="扩展阅读"><a class="header-anchor" href="#扩展阅读"></a>扩展阅读</h2>
<ul>
<li>[PEP 0318 – Decorators for Functions and Methods](PEP 0318 – Decorators for Functions and Methods)</li>
<li><a href="http://python-3-patterns-idioms-test.readthedocs.io/en/latest/PythonDecorators.html" target="_blank" rel="noopener">Python Decorator in Detail</a></li>
<li><a href="https://youtu.be/7lmCu8wz8ro?t=45m25s" target="_blank" rel="noopener">What Does it Take to Be an Expert At Python</a></li>
<li><a href="https://foofish.net/python-decorator.html" target="_blank" rel="noopener">理解 Python 装饰器看这一篇就够了</a></li>
<li><a href="http://blog.dscpl.com.au/2014/01/how-you-implemented-your-python.html" target="_blank" rel="noopener">How you implemented your Python decorator is wrong</a></li>
</ul></div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'lotaboutlife';
var disqus_identifier = '2017/Python-Decorator/';
var disqus_title = 'Python Decorator(装饰器)';
var disqus_url = 'https://lotabout.me/2017/Python-Decorator/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>