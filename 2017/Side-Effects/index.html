<!DOCTYPE html><html><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="通常我们说函数式编程时，提到的都是 lambda 表达式，也即函数式编程中的“函数是头等公民”的特点，然而函数式的另一个重要特点： &lt;strong&gt;无副作用&lt;/strong&gt; ，在我看来更为重要。它可以在任何语言中实际应用。今天，我们来谈一谈面向对象中的“副作用”。"><link rel="stylesheet" type="text/css" href="/css/normalize.css"><link rel="stylesheet" type="text/css" href="/css/highlight.css"><link rel="stylesheet" type="text/css" href="/css/noise.css"><title>在面向对象语言中写纯函数！ | 三点水</title><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><meta name="generator" content="Hexo 4.2.1"></head><body><article class="wrapper"><div class="post-main"><div class="nav"><nav class="container"><a class="sidebar-nav-item active" href="/">Home</a><a class="sidebar-nav-item" href="/books">Books</a><a class="sidebar-nav-item" href="/about">About</a></nav><div class="container post-meta"><div class="post-tags"><a class="post-tag-link" href="/tags/FP/" rel="tag">FP</a></div><div class="post-time">2017-04-30</div></div></div><div class="container post-header"><h1>在面向对象语言中写纯函数！</h1></div><div class="container post-toc"><details class="toc"><summary class="toc-accordion">Table of Contents</summary><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#什么是副作用"><span class="toc-number">1.</span> <span class="toc-text">什么是副作用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一些非纯函数"><span class="toc-number">2.</span> <span class="toc-text">一些非纯函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#副作用的危害"><span class="toc-number">3.</span> <span class="toc-text">副作用的危害</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#纯函数的-副作用"><span class="toc-number">4.</span> <span class="toc-text">纯函数的“副作用”</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#小结"><span class="toc-number">5.</span> <span class="toc-text">小结</span></a></li></ol></details></div><div class="container post-content"><p>通常我们说函数式编程时，提到的都是 lambda 表达式，也即函数式编程中的“函数是头等公民”的特点，然而函数式的另一个重要特点： <strong>无副作用</strong> ，在我看来更为重要。它可以在任何语言中实际应用。今天，我们来谈一谈面向对象中的“副作用”。</p>
<h2 id="什么是副作用"><a class="header-anchor" href="#什么是副作用"></a>什么是副作用</h2>
<blockquote>
<p>In computer science, a function or expression is said to have a side effect if
it modifies some state outside its scope or has an observable interaction with
its calling functions or the outside world.</p>
</blockquote>
<p>根据维基百科，在计算机中，当一个函数或表达式修改了自己的域之外的状态或是与函数外的东西有可见的交互，我们就称该函数或表达式有副作用（side effect）。</p>
<p>说得更直白一些，如果调用一个函数，该函数可以（一个或多个）返回值，除此之外，如果函数还修改了参数、全局变量，或是做了 I/O 操作，都说这个函数有副作用。没有副作用的函数被称为 <strong>纯函数</strong>。</p>
<p>为什么要去讨论一个函数有没有“副作用”呢？这是因为，如果一个函数没有副作用，那么可以推出这个函数的结果只依赖于它的参数，这个特性可以给我们带来一些好处，例如：</p>
<ul>
<li>易于并行，同时多线程执行一个纯函数肯定是不会产生竞争的。因为函数需要的资源全都由参数提供。</li>
<li>容易对它做缓存，因为函数的结果只与参数有关，因此可以容易对它做缓存。</li>
<li>易于 debug 及单元测试。只需要给定参数，检查结果即可。</li>
<li>如果一个纯函数的结果没有被使用，则删掉这个函数（及对它的调用）对程序的结果不影响。</li>
</ul>
<h2 id="一些非纯函数"><a class="header-anchor" href="#一些非纯函数"></a>一些非纯函数</h2>
<p>Java 中的各种 setter <strong>不是</strong> 纯函数，因为它修改了函数的参数。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">setBalance</span><span class="params">(<span class="keyword">int</span> newBalance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.balance = newBalance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Account account = <span class="keyword">new</span> Account();</span><br><span class="line">account.setBalance(<span class="number">100</span>); <span class="comment">// equals to setBalance(account, 100);</span></span><br></pre></td></tr></table></figure>
<p>在上例中，执行完 <code>setBalance(account, 100)</code> 后， <code>account</code> 的值发生了变化，因此不是纯函数。推而广之，任何类的方法，只要修改了类的属性，则该函数不是纯函数。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">last = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nextRand</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> last</span><br><span class="line">    last = last * <span class="number">13</span> % <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br></pre></td></tr></table></figure>
<p>上例中， <code>nextRand()</code> 函数读取并写入全局变量，因此 <strong>不是</strong> 纯函数。要注意的是只要读入 <strong>或</strong> 写入全局变量都属于副作用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def func(x):</span><br><span class="line">    print &quot;x is &quot;, x</span><br></pre></td></tr></table></figure>
<p>上述函数做了 I/O 操作，也不是纯函数。</p>
<p>结合上面的例子，其实有一个特别简单的判断，如果用相同的参数调用一个函数任意多次，它们返回的结果是一样的，则这个函数就是 <strong>纯函数</strong>，反之则不是。</p>
<h2 id="副作用的危害"><a class="header-anchor" href="#副作用的危害"></a>副作用的危害</h2>
<p>单看上面的例子，我们看不出“副作用”的巨大危害，但 <strong>避免副作用</strong> 的思想一定要有！这里举一个在工作上被副作用坑害的例子，用以警告大家去避免函数的副作用。</p>
<p>这个例子是真实场景下出现的一个问题，只是这里简化了其中的逻辑与需求。</p>
<p>需求是检查两个帐号的信息，判断它们是否雷同/相似，并给出相同的字段。于是有了类似下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountComparator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map sameFields = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="keyword">private</span> Map diffFields = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map <span class="title">compare</span><span class="params">(Account a, Account b)</span> </span>&#123;</span><br><span class="line">        bool sameName = a.getName().equal(b.getName());</span><br><span class="line">        bool sameEmail = a.getEmail().equal(b.getEmail());</span><br><span class="line">        bool sameBirthday = a.getBirthday().equal(b.getBirthday());</span><br><span class="line"></span><br><span class="line">        saveField(<span class="string">"name"</span>, sameName, a.getName());</span><br><span class="line">        saveField(<span class="string">"email"</span>, sameEmail, a.getEmail());</span><br><span class="line">        saveField(<span class="string">"birthday"</span>, sameEmail, b.getBirthday());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gatherResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">saveField</span><span class="params">(String fieldName, bool isSame, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            sameFields.put(fieldName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            diffFields.put(fieldName, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Result <span class="title">gatherResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Result ret = <span class="keyword">new</span> Result();</span><br><span class="line">        sameFields.forEach((k, v) -&gt; ret.addSameField(k, v));</span><br><span class="line">        diffFields.forEach((k, v) -&gt; ret.addDiffField(k, v));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AccountComparator comparator = <span class="keyword">new</span> AccountComparator();</span><br><span class="line">Result result = comparator.compare(a, b);</span><br></pre></td></tr></table></figure>
<p>这里只对比了其中的三项信息，调用 <code>saveField</code> 把该项结果保存起来，最后调用
<code>gatherResult</code> 得到结果。在谈如何改进之前，这个类有什么问题？</p>
<p>相信你已经发现了，问题在于这个 <code>compare</code> 函数并不是纯函数！那会有什么问题呢？考虑下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Account a &#x3D; new Account(&quot;nameA&quot;, &quot;emailA&quot;, &quot;BirthdayA&quot;);</span><br><span class="line">Account b &#x3D; new Account(&quot;nameA&quot;, &quot;emailB&quot;, &quot;BirthdayB&quot;);</span><br><span class="line">Account duplication_a &#x3D; new Account(&quot;nameA&quot;, &quot;emailA&quot;, &quot;BirthdayA&quot;);</span><br><span class="line"></span><br><span class="line">AccountComparator comparator &#x3D; new AccountComparator();</span><br><span class="line">Result result1 &#x3D; comparator.compare(a, b);</span><br><span class="line">Result result2 &#x3D; comparator.compare(a, duplication_a);</span><br></pre></td></tr></table></figure>
<p>那么 <code>result2</code> 中的 <code>diffFields</code> 包含什么值？我们的预期是空，因为 <code>a</code> 与
<code>duplication_a</code> 是完全一样的，但实际返回时它却包含了 <code>email, birthday</code>。这些字段是调用 <code>compare(a, b)</code> 时留下的！</p>
<p>上例的 bug 是非常难发现的，因为做单元测试时如果没有测连续的调用，或都连续调用的参数设置不好，都是触发不了这个 bug 的。一般也不会特意想到这种例子，否则看代码就能发现 bug 了。</p>
<p>下面是其中的一种改法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AccountComparator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title">compare</span><span class="params">(Account a, Account b)</span> </span>&#123;</span><br><span class="line">        Map sameFields = <span class="keyword">new</span> HashMap();</span><br><span class="line">        Map diffFields = <span class="keyword">new</span> HashMap();</span><br><span class="line"></span><br><span class="line">        bool sameName = a.getName().equal(b.getName());</span><br><span class="line">        bool sameEmail = a.getEmail().equal(b.getEmail());</span><br><span class="line">        bool sameBirthday = a.getBirthday().equal(b.getBirthday());</span><br><span class="line"></span><br><span class="line">        saveField(<span class="string">"name"</span>, sameName, a.getName());</span><br><span class="line">        saveField(<span class="string">"email"</span>, sameEmail, a.getEmail());</span><br><span class="line">        saveField(<span class="string">"birthday"</span>, sameEmail, b.getBirthday());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> gatherResult();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">saveField</span><span class="params">(Map sameFields, Map diffFields,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 String fieldName, bool isSame, String value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isSame) &#123;</span><br><span class="line">            sameFields.put(fieldName, value);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            diffFields.put(fieldName, value);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Result <span class="title">gatherResult</span><span class="params">(Map sameFields, Map diffFields)</span> </span>&#123;</span><br><span class="line">        Result ret = <span class="keyword">new</span> Result();</span><br><span class="line">        sameFields.forEach((k, v) -&gt; ret.addSameField(k, v));</span><br><span class="line">        diffFields.forEach((k, v) -&gt; ret.addDiffField(k, v));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是这里的 <code>saveField</code> 函数依旧不是纯函数，因为它修改了函数的参数
<code>sameFields</code> 与 <code>diffFields</code>。但这里这么做是因为 Java 里对不可变数据结构
(immutable datastructure) 的支持较差。</p>
<p>这样一来，函数 <code>compare</code> 就变成了一个纯函数，因为它所需要的状态全部存在于函数内（包括参数）。就样多次调用该函数也不会有问题的。</p>
<h2 id="纯函数的-副作用"><a class="header-anchor" href="#纯函数的-副作用"></a>纯函数的“副作用”</h2>
<p>如果写的函数都是纯函数会怎么样呢？</p>
<p>首先是没办法与外界交流，因为不能用任意的 I/O操作，这在实际的编程中是绝不可能的。也因此，我们所能做的是尽量将“副作用”缩小到几个函数内，而大部分函数依旧是纯函数。</p>
<p>另一个问题就是效率。就像上面看到的，任意类的 setter 方法都不是纯函数，那么如果非要把类的各种方法都变成纯函数，则每个方法都应该返回一个新的类，例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Account</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> balance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">setBalance</span><span class="params">(<span class="keyword">int</span> newBalance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Account(newBalance);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Account account = <span class="keyword">new</span> Account(<span class="number">10</span>);</span><br><span class="line">account = account.setBalance(<span class="number">100</span>);</span><br></pre></td></tr></table></figure>
<p>这样就会造成一些效率上的问题。那么是不是使用纯函数就是一个平衡的问题。这又涉及面向对象风格与函数式风格的对比。这里不想过多讨论这种问题，但即使是面向对象的语言，也可以尽量写成纯函数。</p>
<h2 id="小结"><a class="header-anchor" href="#小结"></a>小结</h2>
<p>函数式编程的思想包含很多内容，本文介绍了其中的“无副作用”概念，并给出一个实例，试图说明副作用的坏处，并给出一个“无副作用”的实现。最后说明了纯函数的一些弱点。</p>
<p>想要表达的内容其实很简单：即使在面向对象语言中，我们也应该尽量写出无副作用的函数。</p>
<p>希望大家在平时的工作学习中，能够应用得上。</p></div></div><div class="post-main post-comment"><div id="disqus_thread"></div><script type="text/javascript">
var disqus_shortname = 'lotaboutlife';
var disqus_identifier = '2017/Side-Effects/';
var disqus_title = '在面向对象语言中写纯函数！';
var disqus_url = 'https://lotabout.me/2017/Side-Effects/';
(function() {
   var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
   dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
   (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();
</script>
<noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>
<a href="http://disqus.com" target="_blank" rel="noopener" class="dsq-brlink">Blog comments powered by <span class="logo-disqus">Disqus</span></a></div></article><link rel="stylesheet" type="text/css" href="/css/font.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/font-awesome/4.5.0/css/font-awesome.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.css"><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script><script src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js"></script><script>$(document).ready(function() {
  $(".fancybox").fancybox();
});
</script><script>(function(b,o,i,l,e,r){b.GoogleAnalyticsObject=l;b[l]||(b[l]=
function(){(b[l].q=b[l].q||[]).push(arguments)});b[l].l=+new Date;
e=o.createElement(i);r=o.getElementsByTagName(i)[0];
e.src='//www.google-analytics.com/analytics.js';
r.parentNode.insertBefore(e,r)}(window,document,'script','ga'));
ga('create','UA-39956831-2');ga('send','pageview');</script></body></html>