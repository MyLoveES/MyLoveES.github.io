<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content='事件循环 一、事件循环的本质：从快递分拣中心说起 1.1 现实世界类比 1 2 3 4 5 6 7 8 9 10 假设你经营一家快递分拣中心： - **传统阻塞模型**（多线程）： 每个包裹（请求）分配一个工人（线程） 工人必须全程跟踪包裹：接收 → 分拣 → 装车 即使工人90%时间在等待货车，也不能处理其他包裹 - **事件循环模型**： 少数高效工人（事件循环线程） 每个工人管理多个传送带（Socket通道） 工人只处理就绪的包裹（就绪的I/O事件） 1.2 传统模型的瓶颈 事件循环（Event Loop）： 一种程序结构，通过无限循环持续监听并分发I/O事件，其核心组件包括：\n事件队列：存储待处理事件（新连接、数据到达等） 事件分发器：检测哪些通道（Channel）已就绪 事件处理器：处理具体I/O操作的回调函数 二、多路复用技术：事件循环的"火眼金睛" 2.1 从BIO到NIO的演进 模型 工作方式 资源消耗 适用场景 BIO 1线程1连接（阻塞等待） 随连接数线性增长 低并发场景 select 遍历所有fd检查状态 O(n)时间复杂度 少量连接 epoll 回调通知就绪事件 O(1)时间复杂度 万级连接 2.2 epoll的三大核心能力 2.2.1 红黑树管理文件描述符集 1 2 3 4 5 6 7 8 // 创建epoll实例 int epoll_fd = epoll_create1(0); // 添加监控描述符 struct epoll_event event; event.events = EPOLLIN | EPOLLET; // 边缘触发模式 event.data.fd = socket_fd; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;event); 2.2.1 就绪列表与事件回调 1 2 3 4 5 6 7 8 9 // 等待事件发生（毫秒级超时） int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1); // 处理就绪事件 for (int i = 0; i < num_events; i++) { if (events[i].events & EPOLLIN) { handle_read(events[i].data.fd); } } 2.2.3 触发模式选择 水平触发（LT）：只要缓冲区有数据就会持续通知 边缘触发（ET）：仅在状态变化时通知一次（性能更优） 三、Netty的事件循环实现 3.1 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 ┌───────────────────────────┐ │ EventLoopGroup │ │ ┌─────────────────────┐ │ │ │ NioEventLoop[] │ │ │ │ ┌─────────────────┐ │ │ │ │ │ Selector │ │ │ │ │ │ (epoll实例) │ │ │ │ │ └─────────────────┘ │ │ │ │ │ Task Queue │ │ │ │ │ └─────────────────┘ │ │ │ └─────────────────────┘ │ └───────────────────────────┘ 3.2 事件循环线程的生命周期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 简化版事件循环伪代码 public void run() { while (!terminated) { // 阶段1：检测I/O事件 int readyChannels = selector.select(timeout); // 阶段2：处理I/O事件 if (readyChannels > 0) { Set<SelectionKey> keys = selector.selectedKeys(); for (SelectionKey key : keys) { if (key.isReadable()) { handleRead(key); } if (key.isWritable()) { handleWrite(key); } } keys.clear(); } // 阶段3：处理异步任务 runAllTasks(); } } 3.3 关键性能优化手段 I/O比例控制：通过ioRatio参数平衡I/O与任务处理时间 1 2 // 默认配置：I/O操作占用50%时间 NioEventLoopGroup group = new NioEventLoopGroup(4, new DefaultThreadFactory(), 50); 直接内存分配：使用ByteBuf避免JVM堆内存拷贝 零拷贝技术：文件传输通过FileRegion直接操作内核缓冲区 四、性能对比：理论 vs 现实 4.1 理论计算模型 C10K问题公式推导： 传统模型所需线程数 = 并发连接数 × (平均等待时间 / 平均处理时间) 假设：\n'><title>Event Loop</title><link rel=canonical href=https://MyLoveES.github.io/p/event-loop/><link rel=stylesheet href=/scss/style.min.663803bebe609202d5b39d848f2d7c2dc8b598a2d879efa079fa88893d29c49c.css><meta property='og:title' content="Event Loop"><meta property='og:description' content='事件循环 一、事件循环的本质：从快递分拣中心说起 1.1 现实世界类比 1 2 3 4 5 6 7 8 9 10 假设你经营一家快递分拣中心： - **传统阻塞模型**（多线程）： 每个包裹（请求）分配一个工人（线程） 工人必须全程跟踪包裹：接收 → 分拣 → 装车 即使工人90%时间在等待货车，也不能处理其他包裹 - **事件循环模型**： 少数高效工人（事件循环线程） 每个工人管理多个传送带（Socket通道） 工人只处理就绪的包裹（就绪的I/O事件） 1.2 传统模型的瓶颈 事件循环（Event Loop）： 一种程序结构，通过无限循环持续监听并分发I/O事件，其核心组件包括：\n事件队列：存储待处理事件（新连接、数据到达等） 事件分发器：检测哪些通道（Channel）已就绪 事件处理器：处理具体I/O操作的回调函数 二、多路复用技术：事件循环的"火眼金睛" 2.1 从BIO到NIO的演进 模型 工作方式 资源消耗 适用场景 BIO 1线程1连接（阻塞等待） 随连接数线性增长 低并发场景 select 遍历所有fd检查状态 O(n)时间复杂度 少量连接 epoll 回调通知就绪事件 O(1)时间复杂度 万级连接 2.2 epoll的三大核心能力 2.2.1 红黑树管理文件描述符集 1 2 3 4 5 6 7 8 // 创建epoll实例 int epoll_fd = epoll_create1(0); // 添加监控描述符 struct epoll_event event; event.events = EPOLLIN | EPOLLET; // 边缘触发模式 event.data.fd = socket_fd; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;event); 2.2.1 就绪列表与事件回调 1 2 3 4 5 6 7 8 9 // 等待事件发生（毫秒级超时） int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1); // 处理就绪事件 for (int i = 0; i < num_events; i++) { if (events[i].events & EPOLLIN) { handle_read(events[i].data.fd); } } 2.2.3 触发模式选择 水平触发（LT）：只要缓冲区有数据就会持续通知 边缘触发（ET）：仅在状态变化时通知一次（性能更优） 三、Netty的事件循环实现 3.1 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 ┌───────────────────────────┐ │ EventLoopGroup │ │ ┌─────────────────────┐ │ │ │ NioEventLoop[] │ │ │ │ ┌─────────────────┐ │ │ │ │ │ Selector │ │ │ │ │ │ (epoll实例) │ │ │ │ │ └─────────────────┘ │ │ │ │ │ Task Queue │ │ │ │ │ └─────────────────┘ │ │ │ └─────────────────────┘ │ └───────────────────────────┘ 3.2 事件循环线程的生命周期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 简化版事件循环伪代码 public void run() { while (!terminated) { // 阶段1：检测I/O事件 int readyChannels = selector.select(timeout); // 阶段2：处理I/O事件 if (readyChannels > 0) { Set<SelectionKey> keys = selector.selectedKeys(); for (SelectionKey key : keys) { if (key.isReadable()) { handleRead(key); } if (key.isWritable()) { handleWrite(key); } } keys.clear(); } // 阶段3：处理异步任务 runAllTasks(); } } 3.3 关键性能优化手段 I/O比例控制：通过ioRatio参数平衡I/O与任务处理时间 1 2 // 默认配置：I/O操作占用50%时间 NioEventLoopGroup group = new NioEventLoopGroup(4, new DefaultThreadFactory(), 50); 直接内存分配：使用ByteBuf避免JVM堆内存拷贝 零拷贝技术：文件传输通过FileRegion直接操作内核缓冲区 四、性能对比：理论 vs 现实 4.1 理论计算模型 C10K问题公式推导： 传统模型所需线程数 = 并发连接数 × (平均等待时间 / 平均处理时间) 假设：\n'><meta property='og:url' content='https://MyLoveES.github.io/p/event-loop/'><meta property='og:site_name' content='Kunkka'><meta property='og:type' content='article'><meta property='article:section' content='Post'><meta property='article:tag' content='并发'><meta property='article:tag' content='事件循环'><meta property='article:tag' content='Node.js'><meta property='article:published_time' content='2025-03-10T00:00:00+00:00'><meta property='article:modified_time' content='2025-03-10T00:00:00+00:00'><meta name=twitter:title content="Event Loop"><meta name=twitter:description content='事件循环 一、事件循环的本质：从快递分拣中心说起 1.1 现实世界类比 1 2 3 4 5 6 7 8 9 10 假设你经营一家快递分拣中心： - **传统阻塞模型**（多线程）： 每个包裹（请求）分配一个工人（线程） 工人必须全程跟踪包裹：接收 → 分拣 → 装车 即使工人90%时间在等待货车，也不能处理其他包裹 - **事件循环模型**： 少数高效工人（事件循环线程） 每个工人管理多个传送带（Socket通道） 工人只处理就绪的包裹（就绪的I/O事件） 1.2 传统模型的瓶颈 事件循环（Event Loop）： 一种程序结构，通过无限循环持续监听并分发I/O事件，其核心组件包括：\n事件队列：存储待处理事件（新连接、数据到达等） 事件分发器：检测哪些通道（Channel）已就绪 事件处理器：处理具体I/O操作的回调函数 二、多路复用技术：事件循环的"火眼金睛" 2.1 从BIO到NIO的演进 模型 工作方式 资源消耗 适用场景 BIO 1线程1连接（阻塞等待） 随连接数线性增长 低并发场景 select 遍历所有fd检查状态 O(n)时间复杂度 少量连接 epoll 回调通知就绪事件 O(1)时间复杂度 万级连接 2.2 epoll的三大核心能力 2.2.1 红黑树管理文件描述符集 1 2 3 4 5 6 7 8 // 创建epoll实例 int epoll_fd = epoll_create1(0); // 添加监控描述符 struct epoll_event event; event.events = EPOLLIN | EPOLLET; // 边缘触发模式 event.data.fd = socket_fd; epoll_ctl(epoll_fd, EPOLL_CTL_ADD, socket_fd, &amp;event); 2.2.1 就绪列表与事件回调 1 2 3 4 5 6 7 8 9 // 等待事件发生（毫秒级超时） int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1); // 处理就绪事件 for (int i = 0; i < num_events; i++) { if (events[i].events & EPOLLIN) { handle_read(events[i].data.fd); } } 2.2.3 触发模式选择 水平触发（LT）：只要缓冲区有数据就会持续通知 边缘触发（ET）：仅在状态变化时通知一次（性能更优） 三、Netty的事件循环实现 3.1 核心组件关系图 1 2 3 4 5 6 7 8 9 10 11 12 ┌───────────────────────────┐ │ EventLoopGroup │ │ ┌─────────────────────┐ │ │ │ NioEventLoop[] │ │ │ │ ┌─────────────────┐ │ │ │ │ │ Selector │ │ │ │ │ │ (epoll实例) │ │ │ │ │ └─────────────────┘ │ │ │ │ │ Task Queue │ │ │ │ │ └─────────────────┘ │ │ │ └─────────────────────┘ │ └───────────────────────────┘ 3.2 事件循环线程的生命周期 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 简化版事件循环伪代码 public void run() { while (!terminated) { // 阶段1：检测I/O事件 int readyChannels = selector.select(timeout); // 阶段2：处理I/O事件 if (readyChannels > 0) { Set<SelectionKey> keys = selector.selectedKeys(); for (SelectionKey key : keys) { if (key.isReadable()) { handleRead(key); } if (key.isWritable()) { handleWrite(key); } } keys.clear(); } // 阶段3：处理异步任务 runAllTasks(); } } 3.3 关键性能优化手段 I/O比例控制：通过ioRatio参数平衡I/O与任务处理时间 1 2 // 默认配置：I/O操作占用50%时间 NioEventLoopGroup group = new NioEventLoopGroup(4, new DefaultThreadFactory(), 50); 直接内存分配：使用ByteBuf避免JVM堆内存拷贝 零拷贝技术：文件传输通过FileRegion直接操作内核缓冲区 四、性能对比：理论 vs 现实 4.1 理论计算模型 C10K问题公式推导： 传统模型所需线程数 = 并发连接数 × (平均等待时间 / 平均处理时间) 假设：\n'><link rel="shortcut icon" href=/favicon.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_hu_c68a00bbf16dac8.png width=300 height=300 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Kunkka</a></h1><h2 class=site-description>wind rises</h2></div></header><ol class=menu-social><li><a href=https://github.com/MyLoveES target=_blank title=GitHub rel=me><svg class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=/index.xml target=_blank title=RSS rel=me><svg class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/search/><svg class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/about><svg class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li><a href=/archives><svg class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/all-categories><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg>
<span>Categories</span></a></li><li><a href=/links><svg class="icon icon-tabler icon-tabler-link" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M10 14a3.5 3.5.0 005 0l4-4a3.5 3.5.0 00-5-5l-.5.5"/><path d="M14 10a3.5 3.5.0 00-5 0l-4 4a3.5 3.5.0 005 5l.5-.5"/></svg>
<span>Links</span></a></li><li><a href=/all-tags><svg class="icon icon-tabler icon-tabler-tag" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11 3l9 9a1.5 1.5.0 010 2l-6 6a1.5 1.5.0 01-2 0L3 11V7a4 4 0 014-4h4"/><circle cx="9" cy="9" r="2"/></svg>
<span>Tags</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#一事件循环的本质从快递分拣中心说起>一、事件循环的本质：从快递分拣中心说起</a><ol><li><a href=#11-现实世界类比>1.1 现实世界类比</a></li><li><a href=#12-传统模型的瓶颈>1.2 传统模型的瓶颈</a></li></ol></li><li><a href=#二多路复用技术事件循环的火眼金睛>二、多路复用技术：事件循环的"火眼金睛"</a><ol><li><a href=#21-从bio到nio的演进>2.1 从BIO到NIO的演进</a></li></ol></li><li><a href=#22-epoll的三大核心能力>2.2 epoll的三大核心能力</a><ol><li><a href=#221-红黑树管理文件描述符集>2.2.1 红黑树管理文件描述符集</a></li><li><a href=#221-就绪列表与事件回调>2.2.1 就绪列表与事件回调</a></li><li><a href=#223-触发模式选择>2.2.3 触发模式选择</a></li></ol></li><li><a href=#三netty的事件循环实现>三、Netty的事件循环实现</a><ol><li><a href=#31-核心组件关系图>3.1 核心组件关系图</a></li><li><a href=#32-事件循环线程的生命周期>3.2 事件循环线程的生命周期</a></li><li><a href=#33-关键性能优化手段>3.3 关键性能优化手段</a></li></ol></li><li><a href=#四性能对比理论-vs-现实>四、性能对比：理论 vs 现实</a><ol><li><a href=#41-理论计算模型>4.1 理论计算模型</a></li></ol></li><li><a href=#五从内核到应用全链路视角看事件循环>五、从内核到应用：全链路视角看事件循环</a><ol><li><a href=#51-linux内核的工作流程>5.1 Linux内核的工作流程</a></li><li><a href=#52-现代网络栈优化>5.2 现代网络栈优化</a></li></ol></li><li><a href=#六最佳实践如何最大化事件循环效率>六、最佳实践：如何最大化事件循环效率</a><ol><li><a href=#61-配置原则>6.1 配置原则</a></li><li><a href=#62-禁忌事项>6.2 禁忌事项</a></li><li><a href=#63-监控指标>6.3 监控指标</a></li></ol></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/%E6%8A%80%E6%9C%AF/>技术</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/p/event-loop/>Event Loop</a></h2></div><footer class=article-time><div><svg class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Mar 10, 2025</time></div><div><svg class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>2 minute read</time></div></footer></div></header><section class=article-content><h1 id=事件循环>事件循环</h1><hr><h2 id=一事件循环的本质从快递分拣中心说起>一、事件循环的本质：从快递分拣中心说起</h2><h3 id=11-现实世界类比>1.1 现实世界类比</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-plaintext data-lang=plaintext><span class=line><span class=cl>假设你经营一家快递分拣中心：
</span></span><span class=line><span class=cl>- **传统阻塞模型**（多线程）：
</span></span><span class=line><span class=cl>  每个包裹（请求）分配一个工人（线程）
</span></span><span class=line><span class=cl>  工人必须全程跟踪包裹：接收 → 分拣 → 装车
</span></span><span class=line><span class=cl>  即使工人90%时间在等待货车，也不能处理其他包裹
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>- **事件循环模型**：
</span></span><span class=line><span class=cl>  少数高效工人（事件循环线程）
</span></span><span class=line><span class=cl>  每个工人管理多个传送带（Socket通道）
</span></span><span class=line><span class=cl>  工人只处理就绪的包裹（就绪的I/O事件）
</span></span></code></pre></td></tr></table></div></div><h3 id=12-传统模型的瓶颈>1.2 传统模型的瓶颈</h3><p><strong>事件循环（Event Loop）：</strong>
一种程序结构，通过无限循环持续监听并分发I/O事件，其核心组件包括：</p><ul><li>事件队列：存储待处理事件（新连接、数据到达等）</li><li>事件分发器：检测哪些通道（Channel）已就绪</li><li>事件处理器：处理具体I/O操作的回调函数</li></ul><h2 id=二多路复用技术事件循环的火眼金睛>二、多路复用技术：事件循环的"火眼金睛"</h2><h3 id=21-从bio到nio的演进>2.1 从BIO到NIO的演进</h3><div class=table-wrapper><table><thead><tr><th>模型</th><th>工作方式</th><th>资源消耗</th><th>适用场景</th></tr></thead><tbody><tr><td>BIO</td><td>1线程1连接（阻塞等待）</td><td>随连接数线性增长</td><td>低并发场景</td></tr><tr><td>select</td><td>遍历所有fd检查状态</td><td>O(n)时间复杂度</td><td>少量连接</td></tr><tr><td>epoll</td><td>回调通知就绪事件</td><td>O(1)时间复杂度</td><td>万级连接</td></tr></tbody></table></div><h2 id=22-epoll的三大核心能力>2.2 epoll的三大核心能力</h2><h3 id=221-红黑树管理文件描述符集>2.2.1 红黑树管理文件描述符集</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 创建epoll实例
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>epoll_fd</span> <span class=o>=</span> <span class=nf>epoll_create1</span><span class=p>(</span><span class=mi>0</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 添加监控描述符
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>struct</span> <span class=n>epoll_event</span> <span class=n>event</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=n>event</span><span class=p>.</span><span class=n>events</span> <span class=o>=</span> <span class=n>EPOLLIN</span> <span class=o>|</span> <span class=n>EPOLLET</span><span class=p>;</span> <span class=c1>// 边缘触发模式
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=n>event</span><span class=p>.</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span> <span class=o>=</span> <span class=n>socket_fd</span><span class=p>;</span>
</span></span><span class=line><span class=cl><span class=nf>epoll_ctl</span><span class=p>(</span><span class=n>epoll_fd</span><span class=p>,</span> <span class=n>EPOLL_CTL_ADD</span><span class=p>,</span> <span class=n>socket_fd</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>event</span><span class=p>);</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=221-就绪列表与事件回调>2.2.1 就绪列表与事件回调</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-c data-lang=c><span class=line><span class=cl><span class=c1>// 等待事件发生（毫秒级超时）
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=kt>int</span> <span class=n>num_events</span> <span class=o>=</span> <span class=nf>epoll_wait</span><span class=p>(</span><span class=n>epoll_fd</span><span class=p>,</span> <span class=n>events</span><span class=p>,</span> <span class=n>MAX_EVENTS</span><span class=p>,</span> <span class=o>-</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=c1>// 处理就绪事件
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=k>for</span> <span class=p>(</span><span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span> <span class=n>i</span> <span class=o>&lt;</span> <span class=n>num_events</span><span class=p>;</span> <span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>events</span> <span class=o>&amp;</span> <span class=n>EPOLLIN</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=nf>handle_read</span><span class=p>(</span><span class=n>events</span><span class=p>[</span><span class=n>i</span><span class=p>].</span><span class=n>data</span><span class=p>.</span><span class=n>fd</span><span class=p>);</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=223-触发模式选择>2.2.3 触发模式选择</h3><ul><li>水平触发（LT）：只要缓冲区有数据就会持续通知</li><li>边缘触发（ET）：仅在状态变化时通知一次（性能更优）</li></ul><h2 id=三netty的事件循环实现>三、Netty的事件循环实现</h2><h3 id=31-核心组件关系图>3.1 核心组件关系图</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>┌───────────────────────────┐
</span></span><span class=line><span class=cl>│        EventLoopGroup     │
</span></span><span class=line><span class=cl>│  ┌─────────────────────┐  │
</span></span><span class=line><span class=cl>│  │   NioEventLoop[]    │  │
</span></span><span class=line><span class=cl>│  │ ┌─────────────────┐ │  │
</span></span><span class=line><span class=cl>│  │ │   Selector      │ │  │
</span></span><span class=line><span class=cl>│  │ │  (epoll实例)     │ │  │
</span></span><span class=line><span class=cl>│  │ └─────────────────┘ │  │
</span></span><span class=line><span class=cl>│  │ │  Task Queue     │ │  │
</span></span><span class=line><span class=cl>│  │ └─────────────────┘ │  │
</span></span><span class=line><span class=cl>│  └─────────────────────┘  │
</span></span><span class=line><span class=cl>└───────────────────────────┘
</span></span></code></pre></td></tr></table></div></div><h3 id=32-事件循环线程的生命周期>3.2 事件循环线程的生命周期</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 简化版事件循环伪代码
</span></span><span class=line><span class=cl>public void run() {
</span></span><span class=line><span class=cl>    while (!terminated) {
</span></span><span class=line><span class=cl>        // 阶段1：检测I/O事件
</span></span><span class=line><span class=cl>        int readyChannels = selector.select(timeout);
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        // 阶段2：处理I/O事件
</span></span><span class=line><span class=cl>        if (readyChannels &gt; 0) {
</span></span><span class=line><span class=cl>            Set&lt;SelectionKey&gt; keys = selector.selectedKeys();
</span></span><span class=line><span class=cl>            for (SelectionKey key : keys) {
</span></span><span class=line><span class=cl>                if (key.isReadable()) {
</span></span><span class=line><span class=cl>                    handleRead(key);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>                if (key.isWritable()) {
</span></span><span class=line><span class=cl>                    handleWrite(key);
</span></span><span class=line><span class=cl>                }
</span></span><span class=line><span class=cl>            }
</span></span><span class=line><span class=cl>            keys.clear();
</span></span><span class=line><span class=cl>        }
</span></span><span class=line><span class=cl>        
</span></span><span class=line><span class=cl>        // 阶段3：处理异步任务
</span></span><span class=line><span class=cl>        runAllTasks();
</span></span><span class=line><span class=cl>    }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><h3 id=33-关键性能优化手段>3.3 关键性能优化手段</h3><ol><li>I/O比例控制：通过ioRatio参数平衡I/O与任务处理时间</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>// 默认配置：I/O操作占用50%时间
</span></span><span class=line><span class=cl>NioEventLoopGroup group = new NioEventLoopGroup(4, new DefaultThreadFactory(), 50);
</span></span></code></pre></td></tr></table></div></div><ol start=2><li>直接内存分配：使用ByteBuf避免JVM堆内存拷贝</li><li>零拷贝技术：文件传输通过FileRegion直接操作内核缓冲区</li></ol><h2 id=四性能对比理论-vs-现实>四、性能对比：理论 vs 现实</h2><h3 id=41-理论计算模型>4.1 理论计算模型</h3><p><strong>C10K问题公式推导：</strong>
传统模型所需线程数 = 并发连接数 × (平均等待时间 / 平均处理时间)
假设：</p><ul><li>10,000并发连接</li><li>每个请求95%时间在等待（19ms等待 + 1ms处理）</li></ul><p>传统模型线程数 = 10,000 × (19/1) = 190,000 → 完全不可行<br>事件循环模型线程数 = CPU核心数（如4线程）→ 轻松应对</p><h2 id=五从内核到应用全链路视角看事件循环>五、从内核到应用：全链路视角看事件循环</h2><h3 id=51-linux内核的工作流程>5.1 Linux内核的工作流程</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>应用层（Java NIO）
</span></span><span class=line><span class=cl>  ↓ 系统调用（epoll_ctl/epoll_wait）
</span></span><span class=line><span class=cl>VFS（虚拟文件系统层）
</span></span><span class=line><span class=cl>  ↓ 回调注册
</span></span><span class=line><span class=cl>网卡驱动
</span></span><span class=line><span class=cl>  ↓ 硬件中断
</span></span><span class=line><span class=cl>DMA缓冲区 → 数据就绪 → 触发epoll回调
</span></span></code></pre></td></tr></table></div></div><h3 id=52-现代网络栈优化>5.2 现代网络栈优化</h3><ol><li>RSS（接收端扩展）：多队列网卡分散中断压力</li><li>SO_REUSEPORT：允许多个Socket监听同一端口</li><li>Kernel Bypass：DPDK/XDK等用户态网络方案</li></ol><h2 id=六最佳实践如何最大化事件循环效率>六、最佳实践：如何最大化事件循环效率</h2><h3 id=61-配置原则>6.1 配置原则</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-yaml data-lang=yaml><span class=line><span class=cl><span class=c># 推荐Netty配置</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>server</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>netty</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>event-loop</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>boss-count</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>               </span><span class=c># 接收连接线程数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>worker-count</span><span class=p>:</span><span class=w> </span><span class=l>cpu_cores * 2</span><span class=w> </span><span class=c># 处理I/O线程数</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>max-initial-line-length</span><span class=p>:</span><span class=w> </span><span class=m>8192</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>so-backlog</span><span class=p>:</span><span class=w> </span><span class=m>1024</span><span class=w>              </span><span class=c># 等待连接队列大小</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><h3 id=62-禁忌事项>6.2 禁忌事项</h3><ul><li>❌ 在事件循环线程执行阻塞操作</li><li>❌ 忘记释放ByteBuf导致内存泄漏</li><li>❌ 在Handler中处理耗时业务逻辑</li></ul><h3 id=63-监控指标>6.3 监控指标</h3><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>关键Metric：
</span></span><span class=line><span class=cl>  reactor.netty.io.allocated.direct：直接内存使用量
</span></span><span class=line><span class=cl>  reactor.netty.io.pending.tasks：待处理任务数
</span></span><span class=line><span class=cl>  reactor.netty.io.select.latency：select操作延迟
</span></span></code></pre></td></tr></table></div></div></section><footer class=article-footer><section class=article-tags><a href=/tags/%E5%B9%B6%E5%8F%91/>并发</a>
<a href=/tags/%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF/>事件循环</a>
<a href=/tags/node.js/>Node.js</a></section><section class=article-copyright><svg class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/p/why-threads-are-a-bad-idea-for-most-purposes/><div class=article-details><h2 class=article-title>Why threads are a bad idea (for most purposes)</h2></div></a></article><article><a href=/p/code-without-theadpool/><div class=article-details><h2 class=article-title>Code without TheadPool</h2></div></a></article><article><a href=/p/disconas-immich/><div class=article-details><h2 class=article-title>DiscoNAS Immich</h2></div></a></article><article><a href=/p/disconas-media-library/><div class=article-details><h2 class=article-title>DiscoNAS Media Library</h2></div></a></article><article><a href=/p/why-reactor/><div class=article-details><h2 class=article-title>Why Reactor</h2></div></a></article></div></div></aside><div class=disqus-container><div id=disqus_thread></div><script>window.disqus_config=function(){},function(){if(["localhost","127.0.0.1"].indexOf(window.location.hostname)!=-1){document.getElementById("disqus_thread").innerHTML="Disqus comments not available by default when the website is previewed locally.";return}var t=document,e=t.createElement("script");e.async=!0,e.src="//weasley.disqus.com/embed.js",e.setAttribute("data-timestamp",+new Date),(t.head||t.body).appendChild(e)}()</script><noscript>Please enable JavaScript to view the <a href=https://disqus.com/?ref_noscript>comments powered by Disqus.</a></noscript><a href=https://disqus.com class=dsq-brlink>comments powered by <span class=logo-disqus>Disqus</span></a></div><style>.disqus-container{background-color:var(--card-background);border-radius:var(--card-border-radius);box-shadow:var(--shadow-l1);padding:var(--card-padding)}</style><script>window.addEventListener("onColorSchemeChange",e=>{typeof DISQUS=="object"&&DISQUS.reset({reload:!0})})</script><footer class=site-footer><section class=copyright>&copy;
2020 -
2025 Kunkka</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=3.30.0>Stack</a></b> designed by <a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.1e9a3bafd846ced4c345d084b355fb8c7bae75701c338f8a1f8a82c780137826.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>