title: 容错一致 Reaching agreement in the presence of faults
date: 2022-08-11
tags: [Distributed]
categories: Distributed
toc: true
---
# Q：处理器、进程或者节点各自独立，如何才能够达成共识？  

一般情况下，节点间可以彼此传递消息达成一致。但是有故障节点存在的是时候，故障节点可能会向其他节点发送一个错误值，或者发送一些随即值，甚至不发送，导致每个处理器获取到不同的数据，最终计算出不一致的结果。
```
比如，处理器间的时钟同步，集群服务器间的数据同步
```
Reaching Agreement in the Presence of Faults 论文作者提出一种方法来消除错误处理器的影响 - 通过使用循环多轮的信息交换方案来处理;这样的方案可能会迫使有错误的处理器暴露自己有错误，或者至少使其行为与没有错误的处理器保持一致，从而使后者能够达成一致(当然，是在一定的条件下)。

# Assumptions 
  
假设总共有n个独立节点，其中错误节点m个，并且不知道具体是哪些节点出现了问题。节点之间只能双方彼此通信，并且假设数据传输是有保障的并且无延迟。接收方可以识别消息的发出者。  
每个节点n具有私有值Vn（可以理解为当前该节点的状态，比如负载等）。对于给定的m、n，通过彼此间的信息交换，让每个节点持有一个所有节点私有值的向量。最终达成：  
- 非故障节点能够计算得到完全相同的向量;
- 该向量中，非错误节点的所对应的元素元素，是该节点的私有值
  
举个例子： 

{% asset_img ReachAggrement-finger1.png finger1 %}
  
## 交互一致性  
  
虽然我们不需要最终知道哪些节点是有问题的，与错误节点对应的向量元素也可以是任意的;但是正确节点对于错误节点的向量元素必须是一致的。
   
比如下面的这种情况是不被接受的：
{% asset_img ReachAggrement-finger2.png finger2 %}
  
正确节点对所有节点(包括有故障的节点)持有的值达成共识，最终得到（交互式）一致性向量。这样，每个节点就能够通过对该向量的计算，继续得到业务上的所需要的值。  

# 单节点错误
  
首先可以假设 n=4, m=1。进行两轮信息交换：   
1. 各个节点先把自己的私有值发给其他节点  
2. 各个节点彼此交换第一轮收到的信息  
  
在信息交换过程中，错误节点可能会发出错误的值，或者不发出任何值，来干扰其他正常节点的计算。对于一个正常节点，如果没有收到节点N的消息，会将其置为默认值（假设为NULL）。  
    
STEP1:  
{% asset_img ReachAggrement-finger3.png finger3 %}
STEP2:  
{% asset_img ReachAggrement-finger4.png finger4 %}
  
在两轮信息交换完成后，每个节点都会持有“一组”向量值元素。节点可以选取“多数”作为认可的元素值，形成最终的向量。
{% asset_img ReachAggrement-finger5.png finger5 %}

# n >= 3m + 1
  
回想一下，上一节给出的过程需要两轮信息交换，第一轮“我的私有值是”，第二轮“节点x告诉我他的私有值是....”。在m个节点故障的一般情况下，需要m + 1轮通信。为了描述该算法，可以以更通用的方式描述这种消息交换。
  
P: 节点集合  
V: 值的集合
  

